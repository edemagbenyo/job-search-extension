import 'array-flat-polyfill';
import fs, { readFile, outputJson, readJSONSync } from 'fs-extra';
import flatten from 'lodash.flatten';
import path, { relative, join, basename } from 'path';
import prettier from 'prettier';
import cheerio from 'cheerio';
import { cosmiconfigSync } from 'cosmiconfig';
import memoize from 'mem';
import slash from 'slash';
import glob from 'glob';
import get from 'lodash.get';
import diff from 'lodash.difference';
import Ajv from 'ajv';

const not = (fn) => (x) => !fn(x);

function isChunk(
  x,
) {
  return x.type === 'chunk'
}

function isString(x) {
  return typeof x === 'string'
}

function isJsonFilePath(x) {
  return isString(x) && x.endsWith('json')
}

const formatHtml = ($) =>
  prettier.format($.html(), { parser: 'html' });

/**
 * Update the manifest source in the output bundle
 */
const updateManifest = (
  updater

,
  bundle,
  handleError,
) => {
  try {
    const manifestKey = 'manifest.json';
    const manifestAsset = bundle[manifestKey]; 

    if (!manifestAsset) {
      throw new Error(
        'No manifest.json in the rollup output bundle.',
      )
    }

    const manifest = JSON.parse(
      manifestAsset.source ,
    ); 

    const result = updater(manifest);

    manifestAsset.source = JSON.stringify(result, undefined, 2);
  } catch (error) {
    if (handleError) {
      handleError(error.message);
    } else {
      throw error
    }
  }

  return bundle
};

function reduceToRecord(srcDir) {
  if (srcDir === null || typeof srcDir === 'undefined') {
    // This would be a config error, so should throw
    throw new TypeError('srcDir is null or undefined')
  }

  return (
    inputRecord,
    filename,
  ) => {
    const name = relative(srcDir, filename)
      .split('.')
      .slice(0, -1)
      .join('.');

    if (name in inputRecord) {
      throw new Error(
        `Script files with different extensions should not share names:\n\n"${filename}"\nwill overwrite\n"${inputRecord[name]}"`,
      )
    }

    return { ...inputRecord, [name]: filename }
  }
}

const loadHtml = (filePath) => {
  const htmlCode = fs.readFileSync(filePath, 'utf8');
  const $ = cheerio.load(htmlCode);

  return Object.assign($, { filePath })
};

const getRelativePath = (filePath) => (
  p,
) => {
  const fileDir = path.dirname(filePath);
  const relDir = path.relative(process.cwd(), fileDir);

  return path.join(relDir, p)
};

/* -------------------- SCRIPTS -------------------- */

const getScriptElems = ($) =>
  $('script')
    .not('[data-rollup-asset]')
    .not('[src^="http:"]')
    .not('[src^="https:"]')
    .not('[src^="data:"]')
    .not('[src^="/"]');

// Mutative action
const mutateScriptElems = (
  $

,
) => {
  getScriptElems($)
    .attr('type', 'module')
    .attr('src', (i, value) => {
      // FIXME: @types/cheerio is wrong for AttrFunction: index.d.ts, line 16
      // declare type AttrFunction = (i: number, currentValue: string) => any;
      // eslint-disable-next-line
      // @ts-ignore
      const replaced = value.replace(/\.[jt]sx?/g, '.js');

      return replaced
    });

  return $
};

const getScripts = ($) =>
  getScriptElems($).toArray();

const getScriptSrc = (
  $

,
) =>
  getScripts($)
    .map((elem) => $(elem).attr('src'))
    .filter(isString)
    .map(getRelativePath($.filePath));

/* ----------------- ASSET SCRIPTS ----------------- */

const getAssets = ($) =>
  $('script')
    .filter('[data-rollup-asset="true"]')
    .not('[src^="http:"]')
    .not('[src^="https:"]')
    .not('[src^="data:"]')
    .not('[src^="/"]')
    .toArray();

const getJsAssets = (
  $

,
) =>
  getAssets($)
    .map((elem) => $(elem).attr('src'))
    .filter(isString)
    .map(getRelativePath($.filePath));

/* -------------------- css ------------------- */

const getCss = ($) =>
  $('link')
    .filter('[rel="stylesheet"]')
    .not('[href^="http:"]')
    .not('[href^="https:"]')
    .not('[href^="data:"]')
    .not('[href^="/"]')
    .toArray();

const getCssHrefs = (
  $

,
) =>
  getCss($)
    .map((elem) => $(elem).attr('href'))
    .filter(isString)
    .map(getRelativePath($.filePath));

/* -------------------- img ------------------- */

const getImgs = ($) =>
  $('img')
    .not('[src^="http://"]')
    .not('[src^="https://"]')
    .not('[src^="data:"]')
    .not('[src^="/"]')
    .toArray();

const getFavicons = ($) =>
  $('link[rel="icon"]')
    .not('[href^="http:"]')
    .not('[href^="https:"]')
    .not('[href^="data:"]')
    .not('[href^="/"]')
    .toArray();

const getImgSrcs = (
  $

,
) => {
  return [
    ...getImgs($).map((elem) => $(elem).attr('src')),
    ...getFavicons($).map((elem) => $(elem).attr('href')),
  ]
    .filter(isString)
    .map(getRelativePath($.filePath))
};

/** CheerioStatic objects with a file path */

































const isHtml = (path) => /\.html?$/.test(path);

const name = 'html-inputs';

/* ============================================ */
/*                  HTML-INPUTS                 */
/* ============================================ */

function htmlInputs(
  htmlInputsOptions,
  /** Used for testing */
  cache = {
    scripts: [],
    html: [],
    html$: [],
    js: [],
    css: [],
    img: [],
    input: [],
  } ,
) {
  return {
    name,
    cache,

    /* ============================================ */
    /*                 OPTIONS HOOK                 */
    /* ============================================ */

    options(options) {
      // Skip if cache.input exists
      // cache is dumped in watchChange hook

      // Parse options.input to array
      let input;
      if (typeof options.input === 'string') {
        input = [options.input];
      } else if (Array.isArray(options.input)) {
        input = [...options.input];
      } else if (typeof options.input === 'object') {
        input = Object.values(options.input);
      } else {
        throw new TypeError(
          `options.input cannot be ${typeof options.input}`,
        )
      }

      /* ------------------------------------------------- */
      /*                 HANDLE HTML FILES                 */
      /* ------------------------------------------------- */

      // Filter htm and html files
      cache.html = input.filter(isHtml);

      // If no html files, do nothing
      if (cache.html.length === 0) return options

      // If the cache has been dumped, reload from files
      if (cache.html$.length === 0) {
        // This is all done once
        cache.html$ = cache.html.map(loadHtml);

        cache.js = flatten(cache.html$.map(getScriptSrc));
        cache.css = flatten(cache.html$.map(getCssHrefs));
        cache.img = flatten(cache.html$.map(getImgSrcs));
        cache.scripts = flatten(cache.html$.map(getJsAssets));

        // Cache jsEntries with existing options.input
        cache.input = input.filter(not(isHtml)).concat(cache.js);

        // Prepare cache.html$ for asset emission
        cache.html$.forEach(mutateScriptElems);

        if (cache.input.length === 0) {
          throw new Error(
            'At least one HTML file must have at least one script.',
          )
        }
      }

      // TODO: simply remove HTML files from options.input
      // - Parse HTML and emit chunks and assets in buildStart
      return {
        ...options,
        input: cache.input.reduce(
          reduceToRecord(htmlInputsOptions.srcDir),
          {},
        ),
      }
    },

    /* ============================================ */
    /*              HANDLE FILE CHANGES             */
    /* ============================================ */

    async buildStart() {
      const { srcDir } = htmlInputsOptions;

      if (srcDir) {
        cache.srcDir = srcDir;
      } else {
        throw new TypeError('options.srcDir not initialized')
      }

      const assets = [
        ...cache.css,
        ...cache.img,
        ...cache.scripts,
      ];

      assets.concat(cache.html).forEach((asset) => {
        this.addWatchFile(asset);
      });

      const emitting = assets.map(async (asset) => {
        // Read these files as Buffers
        const source = await readFile(asset);
        const fileName = relative(srcDir, asset);

        this.emitFile({
          type: 'asset',
          source, // Buffer
          fileName,
        });
      });

      cache.html$.map(($) => {
        const source = formatHtml($);
        const fileName = relative(srcDir, $.filePath);

        this.emitFile({
          type: 'asset',
          source, // String
          fileName,
        });
      });

      await Promise.all(emitting);
    },

    watchChange(id) {
      if (id.endsWith('.html') || id.endsWith('manifest.json')) {
        // Dump cache if html file or manifest changes
        cache.html$ = [];
      }
    },
  }
}

const code = "(function () {\n\t'use strict';\n\n\tconst importPath = /*@__PURE__*/JSON.parse('%PATH%');\n\n\timport(importPath);\n\n}());\n";

const cloneObject = (obj) => JSON.parse(JSON.stringify(obj));

const code$1 = "(function () {\n  'use strict';\n\n  function delay(ms) {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    })\n  }\n\n  function captureEvents(events) {\n    const captured = events.map(captureEvent);\n\n    return () => captured.forEach((t) => t())\n\n    function captureEvent(event) {\n      let isCapturePhase = true;\n\n      const callbacks = new Map();\n      const eventArgs = new Set();\n\n      // This is the only listener for the native event\n      event.addListener(handleEvent);\n\n      function handleEvent(...args) {\n        if (isCapturePhase) {\n          // This is before dynamic import completes\n          eventArgs.add(args);\n\n          if (typeof args[2] === 'function') {\n            // During capture phase all messages are async\n            return true\n          } else {\n            // Sync messages or some other event\n            return false\n          }\n        } else {\n          // The callbacks determine the listener return value\n          return callListeners(...args)\n        }\n      }\n\n      // Called when dynamic import is complete\n      //  and when subsequent events fire\n      function callListeners(...args) {\n        let isAsyncCallback = false;\n        callbacks.forEach((options, cb) => {\n          // A callback error should not affect the other callbacks\n          try {\n            isAsyncCallback = cb(...args) || isAsyncCallback;\n          } catch (error) {\n            console.error(error);\n          }\n        });\n\n        if (!isAsyncCallback && typeof args[2] === 'function') {\n          // We made this an async message callback during capture phase\n          //   when the function handleEvent returned true\n          //   so we are responsible to call sendResponse\n          // If the callbacks are sync message callbacks\n          //   the sendMessage callback on the other side\n          //   resolves with no arguments (this is the same behavior)\n          args[2]();\n        }\n\n        // Support events after import is complete\n        return isAsyncCallback\n      }\n\n      // This function will trigger this Event with our stored args\n      function triggerEvents() {\n        // Fire each event for this Event\n        eventArgs.forEach((args) => {\n          callListeners(...args);\n        });\n\n        // Dynamic import is complete\n        isCapturePhase = false;\n        // Don't need these anymore\n        eventArgs.clear();\n      }\n\n      // All future listeners are handled by our code\n      event.addListener = function addListener(cb, ...options) {\n        callbacks.set(cb, options);\n      };\n\n      event.hasListeners = function hasListeners() {\n        return callbacks.size > 0\n      };\n\n      event.hasListener = function hasListener(cb) {\n        return callbacks.has(cb)\n      };\n\n      event.removeListener = function removeListener(cb) {\n        callbacks.delete(cb);\n      };\n\n      event.__isCapturedEvent = true;\n\n      return triggerEvents\n    }\n  }\n\n  function resolvePath(object, path, defaultValue) {\n    return path.split('.').reduce((o, p) => (o ? o[p] : defaultValue), object) ;\n  }\n\n  const eventPaths = /*@__PURE__*/JSON.parse('%EVENTS%'); \n  const importPath = /*@__PURE__*/JSON.parse('%PATH%'); \n  const delayLength = /*@__PURE__*/JSON.parse('%DELAY%');\n\n  const events = eventPaths.map((eventPath) => resolvePath(chrome, eventPath));\n  const triggerEvents = captureEvents(events);\n\n  import(importPath).then(async () => {\n    if (delayLength) await delay(delayLength);\n\n    triggerEvents();\n  });\n\n}());\n";

const code$2 = "(function () {\n  'use strict';\n\n  function captureEvents(events) {\n    const captured = events.map(captureEvent);\n\n    return () => captured.forEach((t) => t())\n\n    function captureEvent(event) {\n      let isCapturePhase = true;\n\n      const callbacks = new Map();\n      const eventArgs = new Set();\n\n      // This is the only listener for the native event\n      event.addListener(handleEvent);\n\n      function handleEvent(...args) {\n        if (isCapturePhase) {\n          // This is before dynamic import completes\n          eventArgs.add(args);\n\n          if (typeof args[2] === 'function') {\n            // During capture phase all messages are async\n            return true\n          } else {\n            // Sync messages or some other event\n            return false\n          }\n        } else {\n          // The callbacks determine the listener return value\n          return callListeners(...args)\n        }\n      }\n\n      // Called when dynamic import is complete\n      //  and when subsequent events fire\n      function callListeners(...args) {\n        let isAsyncCallback = false;\n        callbacks.forEach((options, cb) => {\n          // A callback error should not affect the other callbacks\n          try {\n            isAsyncCallback = cb(...args) || isAsyncCallback;\n          } catch (error) {\n            console.error(error);\n          }\n        });\n\n        if (!isAsyncCallback && typeof args[2] === 'function') {\n          // We made this an async message callback during capture phase\n          //   when the function handleEvent returned true\n          //   so we are responsible to call sendResponse\n          // If the callbacks are sync message callbacks\n          //   the sendMessage callback on the other side\n          //   resolves with no arguments (this is the same behavior)\n          args[2]();\n        }\n\n        // Support events after import is complete\n        return isAsyncCallback\n      }\n\n      // This function will trigger this Event with our stored args\n      function triggerEvents() {\n        // Fire each event for this Event\n        eventArgs.forEach((args) => {\n          callListeners(...args);\n        });\n\n        // Dynamic import is complete\n        isCapturePhase = false;\n        // Don't need these anymore\n        eventArgs.clear();\n      }\n\n      // All future listeners are handled by our code\n      event.addListener = function addListener(cb, ...options) {\n        callbacks.set(cb, options);\n      };\n\n      event.hasListeners = function hasListeners() {\n        return callbacks.size > 0\n      };\n\n      event.hasListener = function hasListener(cb) {\n        return callbacks.has(cb)\n      };\n\n      event.removeListener = function removeListener(cb) {\n        callbacks.delete(cb);\n      };\n\n      event.__isCapturedEvent = true;\n\n      return triggerEvents\n    }\n  }\n\n  function delay(ms) {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    })\n  }\n\n  /**\n   * Get matches from an object of nested objects\n   *\n   * @export\n   * @template T Type of matches\n   * @param {*} object Parent object to search\n   * @param {(x: any) => boolean} pred A predicate function that will receive each property value of an object\n   * @param {string[]} excludeKeys Exclude a property if the key exactly matches\n   * @returns {T[]} The matched values from the parent object\n   */\n  function getDeepMatches(object, pred, excludeKeys) {\n    const keys = typeof object === 'object' ? Object.keys(object) : [];\n\n    return keys.length\n      ? keys\n          .filter((key) => !excludeKeys.includes(key))\n          .reduce((r, key) => {\n            const target = object[key];\n\n            if (target && pred(target)) {\n              return [...r, target]\n            } else {\n              return [...r, ...getDeepMatches(target, pred, excludeKeys)]\n            }\n          }, [] )\n      : []\n  }\n\n  const importPath = /*@__PURE__*/JSON.parse('%PATH%'); \n  const delayLength = /*@__PURE__*/JSON.parse('%DELAY%'); \n  const excludedPaths = /*@__PURE__*/JSON.parse('%EXCLUDE%');\n\n  const events = getDeepMatches(\n    chrome,\n    (x) => typeof x === 'object' && 'addListener' in x,\n    // The webRequest API is not compatible with event pages\n    //  TODO: this can be removed\n    //   if we stop using this wrapper with \"webRequest\" permission\n    excludedPaths.concat(['webRequest']),\n  );\n  const triggerEvents = captureEvents(events);\n\n  import(importPath).then(async () => {\n    if (delayLength) await delay(delayLength);\n\n    triggerEvents();\n  });\n\n}());\n";

/**
 * This options object allows fine-tuning of the dynamic import wrapper.
 *
 * @export
 * @interface DynamicImportWrapper
 */









// FEATURE: add static code analysis for wake events
//  - This will be slower...
function prepImportWrapperScript({
  eventDelay = 0,
  wakeEvents = [],
  excludeNames = ['extension'],
}) {
  const delay = JSON.stringify(eventDelay);
  const events = wakeEvents.length
    ? JSON.stringify(
        wakeEvents.map((ev) => ev.replace(/^chrome\./, '')),
      )
    : false;
  const exclude = JSON.stringify(excludeNames);

  const script = (events
    ? code$1.replace('%EVENTS%', events)
    : code$2.replace('%EXCLUDE%', exclude)
  ).replace('%DELAY%', delay);

  return script
}

const combinePerms = (
  ...permissions
) => {
  const { perms, xperms } = (permissions.flat(
    Infinity,
  ) )
    .filter((perm) => typeof perm !== 'undefined')
    .reduce(
      ({ perms, xperms }, perm) => {
        if (perm.startsWith('!')) {
          xperms.add(perm.slice(1));
        } else {
          perms.add(perm);
        }

        return { perms, xperms }
      },
      { perms: new Set(), xperms: new Set() },
    );

  return [...perms].filter((p) => !xperms.has(p))
};

/* ============================================ */
/*               CHECK PERMISSIONS              */
/* ============================================ */

// export const debugger = s => /chromep?[\s\n]*\.[\s\n]*debugger/.test(s)
// export const enterprise.deviceAttributes = s => /chromep?[\s\n]*\.[\s\n]*enterprise\.deviceAttributes/.test(s)
// export const enterprise.hardwarePlatform = s => /chromep?[\s\n]*\.[\s\n]*enterprise\.hardwarePlatform/.test(s)
// export const enterprise.platformKeys = s => /chromep?[\s\n]*\.[\s\n]*enterprise\.platformKeys/.test(s)
// export const networking.config = s => /chromep?[\s\n]*\.[\s\n]*networking\.config/.test(s)
// export const system.cpu = s => /chromep?[\s\n]*\.[\s\n]*system\.cpu/.test(s)
// export const system.display = s => /chromep?[\s\n]*\.[\s\n]*system\.display/.test(s)
// export const system.memory = s => /chromep?[\s\n]*\.[\s\n]*system\.memory/.test(s)
// export const system.storage = s => /chromep?[\s\n]*\.[\s\n]*system\.storage/.test(s)

const alarms = (s) =>
  /chromep?[\s\n]*\.[\s\n]*alarms/.test(s);

const bookmarks = (s) =>
  /chromep?[\s\n]*\.[\s\n]*bookmarks/.test(s);

const contentSettings = (s) =>
  /chromep?[\s\n]*\.[\s\n]*contentSettings/.test(s);

const contextMenus = (s) =>
  /chromep?[\s\n]*\.[\s\n]*contextMenus/.test(s);

const cookies = (s) =>
  /chromep?[\s\n]*\.[\s\n]*cookies/.test(s);

const declarativeContent = (s) =>
  /chromep?[\s\n]*\.[\s\n]*declarativeContent/.test(s);
const declarativeNetRequest = (s) =>
  /chromep?[\s\n]*\.[\s\n]*declarativeNetRequest/.test(s);
const declarativeWebRequest = (s) =>
  /chromep?[\s\n]*\.[\s\n]*declarativeWebRequest/.test(s);
const desktopCapture = (s) =>
  /chromep?[\s\n]*\.[\s\n]*desktopCapture/.test(s);
const displaySource = (s) =>
  /chromep?[\s\n]*\.[\s\n]*displaySource/.test(s);
const dns = (s) =>
  /chromep?[\s\n]*\.[\s\n]*dns/.test(s);
const documentScan = (s) =>
  /chromep?[\s\n]*\.[\s\n]*documentScan/.test(s);
const downloads = (s) =>
  /chromep?[\s\n]*\.[\s\n]*downloads/.test(s);
const experimental = (s) =>
  /chromep?[\s\n]*\.[\s\n]*experimental/.test(s);
const fileBrowserHandler = (s) =>
  /chromep?[\s\n]*\.[\s\n]*fileBrowserHandler/.test(s);
const fileSystemProvider = (s) =>
  /chromep?[\s\n]*\.[\s\n]*fileSystemProvider/.test(s);
const fontSettings = (s) =>
  /chromep?[\s\n]*\.[\s\n]*fontSettings/.test(s);
const gcm = (s) =>
  /chromep?[\s\n]*\.[\s\n]*gcm/.test(s);
const geolocation = (s) =>
  /chromep?[\s\n]*\.[\s\n]*geolocation/.test(s);
const history = (s) =>
  /chromep?[\s\n]*\.[\s\n]*history/.test(s);
const identity = (s) =>
  /chromep?[\s\n]*\.[\s\n]*identity/.test(s);
const idle = (s) =>
  /chromep?[\s\n]*\.[\s\n]*idle/.test(s);
const idltest = (s) =>
  /chromep?[\s\n]*\.[\s\n]*idltest/.test(s);
const management = (s) =>
  /chromep?[\s\n]*\.[\s\n]*management/.test(s);
const nativeMessaging = (s) =>
  /chromep?[\s\n]*\.[\s\n]*nativeMessaging/.test(s);
const notifications = (s) =>
  /chromep?[\s\n]*\.[\s\n]*notifications/.test(s);
const pageCapture = (s) =>
  /chromep?[\s\n]*\.[\s\n]*pageCapture/.test(s);
const platformKeys = (s) =>
  /chromep?[\s\n]*\.[\s\n]*platformKeys/.test(s);
const power = (s) =>
  /chromep?[\s\n]*\.[\s\n]*power/.test(s);
const printerProvider = (s) =>
  /chromep?[\s\n]*\.[\s\n]*printerProvider/.test(s);
const privacy = (s) =>
  /chromep?[\s\n]*\.[\s\n]*privacy/.test(s);
const processes = (s) =>
  /chromep?[\s\n]*\.[\s\n]*processes/.test(s);
const proxy = (s) =>
  /chromep?[\s\n]*\.[\s\n]*proxy/.test(s);
const sessions = (s) =>
  /chromep?[\s\n]*\.[\s\n]*sessions/.test(s);
const signedInDevices = (s) =>
  /chromep?[\s\n]*\.[\s\n]*signedInDevices/.test(s);
const storage = (s) =>
  /chromep?[\s\n]*\.[\s\n]*storage/.test(s);
const tabCapture = (s) =>
  /chromep?[\s\n]*\.[\s\n]*tabCapture/.test(s);
// export const tabs = s => /chromep?[\s\n]*\.[\s\n]*tabs/.test(s)
const topSites = (s) =>
  /chromep?[\s\n]*\.[\s\n]*topSites/.test(s);
const tts = (s) =>
  /chromep?[\s\n]*\.[\s\n]*tts/.test(s);
const ttsEngine = (s) =>
  /chromep?[\s\n]*\.[\s\n]*ttsEngine/.test(s);
const unlimitedStorage = (s) =>
  /chromep?[\s\n]*\.[\s\n]*unlimitedStorage/.test(s);
const vpnProvider = (s) =>
  /chromep?[\s\n]*\.[\s\n]*vpnProvider/.test(s);
const wallpaper = (s) =>
  /chromep?[\s\n]*\.[\s\n]*wallpaper/.test(s);
const webNavigation = (s) =>
  /chromep?[\s\n]*\.[\s\n]*webNavigation/.test(s);
const webRequest = (s) =>
  /chromep?[\s\n]*\.[\s\n]*webRequest/.test(s);
const webRequestBlocking = (s) =>
  webRequest(s) && s.includes('\'blocking\'');

// TODO: add readClipboard
// TODO: add writeClipboard

var permissions = /*#__PURE__*/Object.freeze({
  __proto__: null,
  alarms: alarms,
  bookmarks: bookmarks,
  contentSettings: contentSettings,
  contextMenus: contextMenus,
  cookies: cookies,
  declarativeContent: declarativeContent,
  declarativeNetRequest: declarativeNetRequest,
  declarativeWebRequest: declarativeWebRequest,
  desktopCapture: desktopCapture,
  displaySource: displaySource,
  dns: dns,
  documentScan: documentScan,
  downloads: downloads,
  experimental: experimental,
  fileBrowserHandler: fileBrowserHandler,
  fileSystemProvider: fileSystemProvider,
  fontSettings: fontSettings,
  gcm: gcm,
  geolocation: geolocation,
  history: history,
  identity: identity,
  idle: idle,
  idltest: idltest,
  management: management,
  nativeMessaging: nativeMessaging,
  notifications: notifications,
  pageCapture: pageCapture,
  platformKeys: platformKeys,
  power: power,
  printerProvider: printerProvider,
  privacy: privacy,
  processes: processes,
  proxy: proxy,
  sessions: sessions,
  signedInDevices: signedInDevices,
  storage: storage,
  tabCapture: tabCapture,
  topSites: topSites,
  tts: tts,
  ttsEngine: ttsEngine,
  unlimitedStorage: unlimitedStorage,
  vpnProvider: vpnProvider,
  wallpaper: wallpaper,
  webNavigation: webNavigation,
  webRequest: webRequest,
  webRequestBlocking: webRequestBlocking
});

/* ============================================ */
/*              DERIVE PERMISSIONS              */
/* ============================================ */

const derivePermissions = (
  set,
  { code },
) =>
  Object.entries(permissions)
    .filter(([, fn]) => fn(code))
    .map(([key]) => key)
    .reduce((s, p) => s.add(p), set);

// /* ============================================ */
// /*                DERIVE MANIFEST               */
// /* ============================================ */

// export function deriveManifest(
//   manifest: ChromeExtensionManifest, // manifest.json
//   ...permissions: string[] | string[][] // will be combined with manifest.permissions
// ): ChromeExtensionManifest {
//   return validateManifest({
//     // SMELL: Is this necessary?
//     manifest_version: 2,
//     ...manifest,
//     permissions: combinePerms(permissions, manifest.permissions),
//   })
// }

/* -------------------------------------------- */
/*                 DERIVE FILES                 */
/* -------------------------------------------- */

function deriveFiles(
  manifest,
  srcDir,
) {
  const files = get(
    manifest,
    'web_accessible_resources',
    [] ,
  ).reduce((r, x) => {
    if (glob.hasMagic(x)) {
      const files = glob.sync(x, { cwd: srcDir });
      return [...r, ...files.map((f) => f.replace(srcDir, ''))]
    } else {
      return [...r, x]
    }
  }, [] );

  const js = [
    ...files.filter((f) => /\.[jt]sx?$/.test(f)),
    ...get(manifest, 'background.scripts', [] ),
    ...get(
      manifest,
      'content_scripts',
      [] ,
    ).reduce((r, { js = [] }) => [...r, ...js], [] ),
  ];

  const html = [
    ...files.filter((f) => /\.html?$/.test(f)),
    get(manifest, 'background.page'),
    get(manifest, 'options_page'),
    get(manifest, 'devtools_page'),
    get(manifest, 'browser_action.default_popup'),
    get(manifest, 'page_action.default_popup'),
    ...Object.values(get(manifest, 'chrome_url_overrides', {})),
  ];

  const css = [
    ...files.filter((f) => f.endsWith('.css')),
    ...get(
      manifest,
      'content_scripts',
      [] ,
    ).reduce(
      (r, { css = [] }) => [...r, ...css],
      [] ,
    ),
  ];

  // TODO: this can be a string or object
  const actionIconSet = [
    'browser_action.default_icon',
    'page_action.default_icon',
  ].reduce((set, query) => {
    const result = get(
      manifest,
      query,
      {},
    );

    if (typeof result === 'string') {
      set.add(result);
    } else {
      Object.values(result).forEach((x) => set.add(x));
    }

    return set
  }, new Set());

  const img = [
    ...actionIconSet,
    ...files.filter((f) =>
      /\.(jpe?g|png|svg|tiff?|gif|webp|bmp|ico)$/i.test(f),
    ),
    ...Object.values(get(manifest, 'icons', {})),
  ];

  // Files like fonts, things that are not expected
  const others = diff(files, css, js, html, img);

  return {
    css: validate(css),
    js: validate(js),
    html: validate(html),
    img: validate(img),
    others: validate(others),
  }

  function validate(ary) {
    return [...new Set(ary.filter(isString))].map((x) =>
      join(srcDir, x),
    )
  }

  function isString(x) {
    return typeof x === 'string'
  }
}

var id = "http://json-schema.org/draft-04/schema#";
var $schema = "http://json-schema.org/draft-04/schema#";
var description = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	positiveInteger: {
		type: "integer",
		minimum: 0
	},
	positiveIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/positiveInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		minItems: 1,
		uniqueItems: true
	}
};
var type = "object";
var properties = {
	id: {
		type: "string"
	},
	$schema: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": {
	},
	multipleOf: {
		type: "number",
		minimum: 0,
		exclusiveMinimum: true
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "boolean",
		"default": false
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "boolean",
		"default": false
	},
	maxLength: {
		$ref: "#/definitions/positiveInteger"
	},
	minLength: {
		$ref: "#/definitions/positiveIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		anyOf: [
			{
				type: "boolean"
			},
			{
				$ref: "#"
			}
		],
		"default": {
		}
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": {
		}
	},
	maxItems: {
		$ref: "#/definitions/positiveInteger"
	},
	minItems: {
		$ref: "#/definitions/positiveIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	maxProperties: {
		$ref: "#/definitions/positiveInteger"
	},
	minProperties: {
		$ref: "#/definitions/positiveIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		anyOf: [
			{
				type: "boolean"
			},
			{
				$ref: "#"
			}
		],
		"default": {
		}
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	"enum": {
		type: "array",
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var dependencies = {
	exclusiveMaximum: [
		"maximum"
	],
	exclusiveMinimum: [
		"minimum"
	]
};
var jsonSchema = {
	id: id,
	$schema: $schema,
	description: description,
	definitions: definitions,
	type: type,
	properties: properties,
	dependencies: dependencies,
	"default": {
}
};

var title = "JSON schema for Google Chrome extension manifest files";
var $schema$1 = "http://json-schema.org/draft-04/schema#";
var type$1 = "object";
var additionalProperties = true;
var required = [
	"manifest_version",
	"name",
	"version"
];
var properties$1 = {
	manifest_version: {
		type: "number",
		description: "One integer specifying the version of the manifest file format your package requires.",
		"enum": [
			2
		],
		minimum: 2,
		maximum: 2
	},
	name: {
		type: "string",
		description: "The name of the extension",
		maxLength: 45
	},
	version: {
		description: "One to four dot-separated integers identifying the version of this extension.",
		$ref: "#/definitions/version_string"
	},
	default_locale: {
		type: "string",
		description: "Specifies the subdirectory of _locales that contains the default strings for this extension.",
		"default": "en"
	},
	description: {
		type: "string",
		description: "A plain text description of the extension",
		maxLength: 132
	},
	icons: {
		type: "object",
		description: "One or more icons that represent the extension, app, or theme. Recommended format: PNG; also BMP, GIF, ICO, JPEG.",
		minProperties: 1,
		properties: {
			"16": {
				$ref: "#/definitions/icon",
				description: "Used as the favicon for an extension's pages and infobar."
			},
			"48": {
				$ref: "#/definitions/icon",
				description: "Used on the extension management page (chrome://extensions)."
			},
			"128": {
				$ref: "#/definitions/icon",
				description: "Used during installation and in the Chrome Web Store."
			},
			"256": {
				$ref: "#/definitions/icon",
				description: "Used during installation and in the Chrome Web Store."
			}
		}
	},
	browser_action: {
		$ref: "#/definitions/action",
		description: "Use browser actions to put icons in the main Google Chrome toolbar, to the right of the address bar. In addition to its icon, a browser action can also have a tooltip, a badge, and a popup."
	},
	page_action: {
		$ref: "#/definitions/action",
		description: "Use the chrome.pageAction API to put icons inside the address bar. Page actions represent actions that can be taken on the current page, but that aren't applicable to all pages."
	},
	background: {
		type: "object",
		description: "The background page is an HTML page that runs in the extension process. It exists for the lifetime of your extension, and only one instance of it at a time is active.",
		properties: {
			persistent: {
				type: "boolean",
				description: "When false, makes the background page an event page (loaded only when needed).",
				"default": true
			},
			page: {
				$ref: "#/definitions/page",
				description: "Specify the HTML of the background page.",
				"default": "background.html"
			},
			scripts: {
				$ref: "#/definitions/scripts",
				description: "A background page will be generated by the extension system that includes each of the files listed in the scripts property.",
				"default": [
					"background.js"
				]
			}
		},
		dependencies: {
			page: {
				not: {
					required: [
						"scripts"
					]
				}
			},
			scripts: {
				not: {
					required: [
						"page"
					]
				}
			}
		}
	},
	chrome_url_overrides: {
		type: "object",
		description: "Override pages are a way to substitute an HTML file from your extension for a page that Google Chrome normally provides.",
		additionalProperties: false,
		maxProperties: 1,
		properties: {
			bookmarks: {
				$ref: "#/definitions/page",
				description: "The page that appears when the user chooses the Bookmark Manager menu item from the Chrome menu or, on Mac, the Bookmark Manager item from the Bookmarks menu. You can also get to this page by entering the URL chrome://bookmarks.",
				"default": "bookmarks.html"
			},
			history: {
				$ref: "#/definitions/page",
				description: "The page that appears when the user chooses the History menu item from the Chrome menu or, on Mac, the Show Full History item from the History menu. You can also get to this page by entering the URL chrome://history.",
				"default": "history.html"
			},
			newtab: {
				$ref: "#/definitions/page",
				description: "The page that appears when the user creates a new tab or window. You can also get to this page by entering the URL chrome://newtab.",
				"default": "newtab.html"
			}
		}
	},
	commands: {
		type: "object",
		description: "Use the commands API to add keyboard shortcuts that trigger actions in your extension, for example, an action to open the browser action or send a command to the extension.",
		patternProperties: {
			".*": {
				$ref: "#/definitions/command"
			},
			"^_execute_browser_action$": {
				$ref: "#/definitions/command"
			},
			"^_execute_page_action$": {
				$ref: "#/definitions/command"
			}
		}
	},
	content_scripts: {
		type: "array",
		description: "Content scripts are JavaScript files that run in the context of web pages.",
		minItems: 1,
		uniqueItems: true,
		items: {
			type: "object",
			required: [
				"matches"
			],
			additionalProperties: false,
			properties: {
				matches: {
					type: "array",
					description: "Specifies which pages this content script will be injected into.",
					minItems: 1,
					uniqueItems: true,
					items: {
						$ref: "#/definitions/match_pattern"
					}
				},
				exclude_matches: {
					type: "array",
					description: "Excludes pages that this content script would otherwise be injected into.",
					uniqueItems: true,
					items: {
						$ref: "#/definitions/match_pattern"
					}
				},
				css: {
					type: "array",
					description: "The list of CSS files to be injected into matching pages. These are injected in the order they appear in this array, before any DOM is constructed or displayed for the page.",
					uniqueItems: true,
					items: {
						$ref: "#/definitions/uri"
					}
				},
				js: {
					$ref: "#/definitions/scripts",
					description: "The list of JavaScript files to be injected into matching pages. These are injected in the order they appear in this array."
				},
				run_at: {
					type: "string",
					description: "Controls when the files in js are injected.",
					"enum": [
						"document_start",
						"document_end",
						"document_idle"
					],
					"default": "document_idle"
				},
				all_frames: {
					type: "boolean",
					description: "Controls whether the content script runs in all frames of the matching page, or only the top frame.",
					"default": false
				},
				include_globs: {
					type: "array",
					description: "Applied after matches to include only those URLs that also match this glob. Intended to emulate the @include Greasemonkey keyword.",
					uniqueItems: true,
					items: {
						$ref: "#/definitions/glob_pattern"
					}
				},
				exclude_globs: {
					type: "array",
					description: "Applied after matches to exclude URLs that match this glob. Intended to emulate the @exclude Greasemonkey keyword.",
					uniqueItems: true,
					items: {
						$ref: "#/definitions/glob_pattern"
					}
				},
				match_about_blank: {
					type: "boolean",
					description: "Whether to insert the content script on about:blank and about:srcdoc.",
					"default": false
				}
			}
		}
	},
	content_security_policy: {
		$ref: "#/definitions/content_security_policy"
	},
	devtools_page: {
		$ref: "#/definitions/page",
		description: "A DevTools extension adds functionality to the Chrome DevTools. It can add new UI panels and sidebars, interact with the inspected page, get information about network requests, and more."
	},
	externally_connectable: {
		type: "object",
		description: "Declares which extensions, apps, and web pages can connect to your extension via runtime.connect and runtime.sendMessage.",
		items: {
			type: "object",
			additionalProperties: false,
			properties: {
				ids: {
					type: "array",
					items: {
						type: "string",
						description: "The IDs of extensions or apps that are allowed to connect. If left empty or unspecified, no extensions or apps can connect."
					}
				},
				matches: {
					type: "array",
					items: {
						type: "string",
						description: "The URL patterns for web pages that are allowed to connect. This does not affect content scripts. If left empty or unspecified, no web pages can connect."
					}
				},
				accepts_tls_channel_id: {
					type: "boolean",
					"default": false,
					description: "Indicates that the extension would like to make use of the TLS channel ID of the web page connecting to it. The web page must also opt to send the TLS channel ID to the extension via setting includeTlsChannelId to true in runtime.connect's connectInfo or runtime.sendMessage's options."
				}
			}
		}
	},
	file_browser_handlers: {
		type: "array",
		description: "You can use this API to enable users to upload files to your website.",
		minItems: 1,
		items: {
			type: "object",
			required: [
				"id",
				"default_title",
				"file_filters"
			],
			additionalProperties: false,
			properties: {
				id: {
					type: "string",
					description: "Used by event handling code to differentiate between multiple file handlers"
				},
				default_title: {
					type: "string",
					description: "What the button will display."
				},
				file_filters: {
					type: "array",
					description: "Filetypes to match.",
					minItems: 1,
					items: {
						type: "string"
					}
				}
			}
		}
	},
	homepage_url: {
		$ref: "#/definitions/uri",
		description: "The URL of the homepage for this extension."
	},
	incognito: {
		type: "string",
		description: "Specify how this extension will behave if allowed to run in incognito mode.",
		"enum": [
			"spanning",
			"split"
		],
		"default": "spanning"
	},
	input_components: {
		type: "array",
		description: "Allows your extension to handle keystrokes, set the composition, and manage the candidate window.",
		items: {
			type: "object",
			required: [
				"name",
				"type",
				"id",
				"description",
				"language",
				"layouts"
			],
			additionalProperties: false,
			properties: {
				name: {
					type: "string"
				},
				type: {
					type: "string"
				},
				id: {
					type: "string"
				},
				description: {
					type: "string"
				},
				language: {
					type: "string"
				},
				layouts: {
					type: "array"
				}
			}
		}
	},
	key: {
		type: "string",
		description: "This value can be used to control the unique ID of an extension, app, or theme when it is loaded during development."
	},
	minimum_chrome_version: {
		$ref: "#/definitions/version_string",
		description: "The version of Chrome that your extension, app, or theme requires, if any."
	},
	nacl_modules: {
		type: "array",
		description: "One or more mappings from MIME types to the Native Client module that handles each type.",
		minItems: 1,
		uniqueItems: true,
		items: {
			type: "object",
			required: [
				"path",
				"mime_type"
			],
			additionalProperties: false,
			properties: {
				path: {
					$ref: "#/definitions/uri",
					description: "The location of a Native Client manifest (a .nmf file) within the extension directory."
				},
				mime_type: {
					$ref: "#/definitions/mime_type",
					description: "The MIME type for which the Native Client module will be registered as content handler."
				}
			}
		}
	},
	oauth2: {
		type: "object",
		description: "Use the Chrome Identity API to authenticate users: the getAuthToken for users logged into their Google Account and the launchWebAuthFlow for users logged into a non-Google account.",
		required: [
			"client_id",
			"scopes"
		],
		additionalProperties: false,
		properties: {
			client_id: {
				type: "string",
				description: "You need to register your app in the Google APIs Console to get the client ID."
			},
			scopes: {
				type: "array",
				minItems: 1,
				items: {
					type: "string"
				}
			}
		}
	},
	offline_enabled: {
		type: "boolean",
		description: "Whether the app or extension is expected to work offline. When Chrome detects that it is offline, apps with this field set to true will be highlighted on the New Tab page."
	},
	omnibox: {
		type: "object",
		description: "The omnibox API allows you to register a keyword with Google Chrome's address bar, which is also known as the omnibox.",
		required: [
			"keyword"
		],
		additionalProperties: false,
		properties: {
			keyword: {
				type: "string",
				description: "The keyward that will trigger your extension."
			}
		}
	},
	optional_permissions: {
		$ref: "#/definitions/permissions",
		description: "Use the chrome.permissions API to request declared optional permissions at run time rather than install time, so users understand why the permissions are needed and grant only those that are necessary."
	},
	options_page: {
		$ref: "#/definitions/page",
		description: "To allow users to customize the behavior of your extension, you may wish to provide an options page. If you do, a link to it will be provided from the extensions management page at chrome://extensions. Clicking the Options link opens a new tab pointing at your options page.",
		"default": "options.html"
	},
	options_ui: {
		type: "object",
		description: "To allow users to customize the behavior of your extension, you may wish to provide an options page. If you do, an Options link will be shown on the extensions management page at chrome://extensions which opens a dialogue containing your options page.",
		required: [
			"page"
		],
		properties: {
			page: {
				type: "string",
				description: "The path to your options page, relative to your extension's root."
			},
			chrome_style: {
				type: "boolean",
				"default": true,
				description: "If true, a Chrome user agent stylesheet will be applied to your options page. The default value is false, but we recommend you enable it for a consistent UI with Chrome."
			},
			open_in_tab: {
				type: "boolean",
				"default": false,
				description: "If true, your extension's options page will be opened in a new tab rather than embedded in chrome://extensions. The default is false, and we recommend that you don't change it. This is only useful to delay the inevitable deprecation of the old options UI! It will be removed soon, so try not to use it. It will break."
			}
		}
	},
	permissions: {
		$ref: "#/definitions/permissions",
		description: "Permissions help to limit damage if your extension or app is compromised by malware. Some permissions are also displayed to users before installation, as detailed in Permission Warnings."
	},
	requirements: {
		type: "object",
		description: "Technologies required by the app or extension. Hosting sites such as the Chrome Web Store may use this list to dissuade users from installing apps or extensions that will not work on their computer.",
		additionalProperties: false,
		properties: {
			"3D": {
				type: "object",
				description: "The '3D' requirement denotes GPU hardware acceleration.",
				required: [
					"features"
				],
				additionalProperties: false,
				properties: {
					features: {
						type: "array",
						description: "List of the 3D-related features your app requires.",
						minItems: 1,
						uniqueItems: true,
						items: {
							type: "string",
							"enum": [
								"webgl"
							]
						}
					}
				}
			},
			plugins: {
				type: "object",
				description: "Indicates if an app or extension requires NPAPI to run. This requirement is enabled by default when the manifest includes the 'plugins' field.",
				required: [
					"npapi"
				],
				additionalProperties: false,
				properties: {
					npapi: {
						type: "boolean",
						"default": true
					}
				}
			}
		}
	},
	sandbox: {
		type: "object",
		description: "Defines an collection of app or extension pages that are to be served in a sandboxed unique origin, and optionally a Content Security Policy to use with them.",
		required: [
			"pages"
		],
		additionalProperties: false,
		properties: {
			pages: {
				type: "array",
				minItems: 1,
				uniqueItems: true,
				items: {
					$ref: "#/definitions/page"
				}
			},
			content_security_policy: {
				$ref: "#/definitions/content_security_policy",
				"default": "sandbox allow-scripts allow-forms"
			}
		}
	},
	short_name: {
		type: "string",
		description: "The short name is typically used where there is insufficient space to display the full name.",
		maxLength: 12
	},
	update_url: {
		$ref: "#/definitions/uri",
		description: "If you publish using the Chrome Developer Dashboard, ignore this field. If you bridge your own extension or app: URL to an update manifest XML file."
	},
	tts_engine: {
		type: "object",
		description: "Register itself as a speech engine.",
		required: [
			"voices"
		],
		additionalProperties: false,
		properties: {
			voices: {
				type: "array",
				description: "Voices the extension can synthesize.",
				minItems: 1,
				uniqueItems: true,
				items: {
					type: "object",
					required: [
						"voice_name",
						"event_types"
					],
					additionalProperties: false,
					properties: {
						voice_name: {
							type: "string",
							description: "Identifies the name of the voice and the engine used."
						},
						lang: {
							type: "string",
							description: "Almost always, a voice can synthesize speech in just a single language. When an engine supports more than one language, it can easily register a separate voice for each language."
						},
						gender: {
							type: "string",
							description: "If your voice corresponds to a male or female voice, you can use this parameter to help clients choose the most appropriate voice for their application."
						},
						event_types: {
							type: "array",
							description: "Events sent to update the client on the progress of speech synthesis.",
							minItems: 1,
							uniqueItems: true,
							items: {
								type: "string",
								description: "",
								"enum": [
									"start",
									"word",
									"sentence",
									"marker",
									"end",
									"error"
								]
							}
						}
					}
				}
			}
		}
	},
	version_name: {
		type: "string",
		description: "In addition to the version field, which is used for update purposes, version_name can be set to a descriptive version string and will be used for display purposes if present."
	},
	web_accessible_resources: {
		type: "array",
		description: "An array of strings specifying the paths (relative to the package root) of packaged resources that are expected to be usable in the context of a web page.",
		minItems: 1,
		uniqueItems: true,
		items: {
			$ref: "#/definitions/uri"
		}
	},
	chrome_settings_overrides: {
	},
	content_pack: {
	},
	current_locale: {
	},
	"import": {
	},
	platforms: {
	},
	signature: {
	},
	spellcheck: {
	},
	storage: {
	},
	system_indicator: {
	}
};
var dependencies$1 = {
	page_action: {
		not: {
			required: [
				"browser_action"
			]
		}
	},
	browser_action: {
		not: {
			required: [
				"page_action"
			]
		}
	},
	content_scripts: {
		not: {
			required: [
				"script_badge"
			]
		}
	},
	script_badge: {
		not: {
			required: [
				"content_scripts"
			]
		}
	}
};
var definitions$1 = {
	action: {
		type: "object",
		properties: {
			default_title: {
				type: "string",
				description: "Tooltip for the main toolbar icon."
			},
			default_popup: {
				$ref: "#/definitions/uri",
				description: "The popup appears when the user clicks the icon."
			},
			default_icon: {
				anyOf: [
					{
						type: "string",
						description: "FIXME: String form is deprecated."
					},
					{
						type: "object",
						description: "Icon for the main toolbar.",
						properties: {
							"19": {
								$ref: "#/definitions/icon"
							},
							"38": {
								$ref: "#/definitions/icon"
							}
						}
					}
				]
			}
		},
		dependencies: {
			name: {
				not: {
					required: [
						"name"
					]
				}
			},
			icons: {
				not: {
					required: [
						"icons"
					]
				}
			},
			popup: {
				not: {
					required: [
						"popup"
					]
				}
			}
		}
	},
	command: {
		type: "object",
		additionalProperties: false,
		properties: {
			description: {
				type: "string"
			},
			suggested_key: {
				type: "object",
				additionalProperties: false,
				patternProperties: {
					"^(default|mac|windows|linux|chromeos)$": {
						type: "string",
						pattern: "^(Ctrl|Command|MacCtrl|Alt|Option)\\+(Shift\\+)?[A-Z]"
					}
				}
			}
		}
	},
	content_security_policy: {
		type: "string",
		description: "This introduces some fairly strict policies that will make extensions more secure by default, and provides you with the ability to create and enforce rules governing the types of content that can be loaded and executed by your extensions and applications.",
		"default": "script-src 'self'; object-src 'self'"
	},
	glob_pattern: {
		type: "string"
	},
	icon: {
		$ref: "#/definitions/uri"
	},
	match_pattern: {
		type: "string",
		pattern: "^((\\*|http|https|file|ftp|chrome-extension):\\/\\/(\\*|\\*\\.[^\\/\\*]+|[^\\/\\*]+)?(\\/.*))|<all_urls>$"
	},
	mime_type: {
		type: "string",
		pattern: "^(?:application|audio|image|message|model|multipart|text|video)\\/[-+.\\w]+$"
	},
	page: {
		$ref: "#/definitions/uri"
	},
	permissions: {
		type: "array",
		uniqueItems: true,
		items: {
			type: "string"
		}
	},
	scripts: {
		type: "array",
		minItems: 1,
		uniqueItems: true,
		items: {
			$ref: "#/definitions/uri"
		}
	},
	uri: {
		type: "string"
	},
	version_string: {
		type: "string",
		pattern: "^(?:\\d{1,5}\\.){0,3}\\d{1,5}$"
	}
};
var manifestSchema = {
	title: title,
	$schema: $schema$1,
	type: type$1,
	additionalProperties: additionalProperties,
	required: required,
	properties: properties$1,
	dependencies: dependencies$1,
	definitions: definitions$1
};

class ValidationError extends Error {
  constructor(msg, errors) {
    super(msg);
    this.name = 'ValidationError';
    this.errors = errors;
  }
  
}

// const jsonSchema = readJSONSync(
//   resolve(__dirname, 'json-schema-draft-04.json'),
// )

// const manifestSchema = readJSONSync(
//   resolve(__dirname, 'schema-web-ext-manifest-v2.json'),
// )

const ajv = new Ajv({
  verbose: true,
  schemaId: 'auto',
  schemas: {
    'http://json-schema.org/draft-04/schema#': jsonSchema,
  },
  strictDefaults: true,
});

// ajv.addMetaSchema(jsonSchema)

const validator = ajv.compile(manifestSchema);

const validateManifest = (
  manifest,
) => {
  if (validator(manifest)) {
    return manifest
  }

  const { errors } = validator;
  const msg = 'There were problems with the extension manifest.';

  throw new ValidationError(msg, errors)
};

function dedupe(x) {
  return [...new Set(x)]
}






















const explorer = cosmiconfigSync('manifest', {
  cache: false,
});

const name$1 = 'manifest-input';

const npmPkgDetails =
  process.env.npm_package_name &&
  process.env.npm_package_version &&
  process.env.npm_package_description
    ? {
        name: process.env.npm_package_name,
        version: process.env.npm_package_version,
        description: process.env.npm_package_description,
      }
    : {
        name: '',
        version: '',
        description: '',
      };

/* ============================================ */
/*                MANIFEST-INPUT                */
/* ============================================ */

function manifestInput(
  {
    dynamicImportWrapper = {},
    pkg = npmPkgDetails,
    publicKey,
    verbose = true,
    cache = {
      assetChanged: false,
      assets: [],
      input: [],
      inputAry: [],
      inputObj: {},
      permsHash: '',
      readFile: new Map(),
      srcDir: null,
    } ,
  } = {} 









,
) {
  const readAssetAsBuffer = memoize(
    (filepath) => {
      return fs.readFile(filepath)
    },
    {
      cache: cache.readFile,
    },
  );

  /* ----------- HOOKS CLOSURES START ----------- */

  let manifestPath;

  const manifestName = 'manifest.json';

  /* ------------ HOOKS CLOSURES END ------------ */

  /* - SETUP DYNAMIC IMPORT LOADER SCRIPT START - */

  let wrapperScript = '';
  if (dynamicImportWrapper !== false) {
    wrapperScript = prepImportWrapperScript(dynamicImportWrapper);
  }

  /* -- SETUP DYNAMIC IMPORT LOADER SCRIPT END -- */

  /* --------------- plugin object -------------- */
  return {
    name: name$1,

    get srcDir() {
      return cache.srcDir
    },

    /* ============================================ */
    /*                 OPTIONS HOOK                 */
    /* ============================================ */

    options(options) {
      // Do not reload manifest without changes
      if (!cache.manifest) {
        /* ----------- LOAD AND PROCESS MANIFEST ----------- */

        let inputManifestPath;
        if (Array.isArray(options.input)) {
          const manifestIndex = options.input.findIndex(
            isJsonFilePath,
          );
          inputManifestPath = options.input[manifestIndex];
          cache.inputAry = [
            ...options.input.slice(0, manifestIndex),
            ...options.input.slice(manifestIndex + 1),
          ];
        } else if (typeof options.input === 'object') {
          inputManifestPath = options.input.manifest;
          cache.inputObj = cloneObject(options.input);
          delete cache.inputObj['manifest'];
        } else {
          inputManifestPath = options.input;
        }

        if (!isJsonFilePath(inputManifestPath)) {
          throw new TypeError(
            'RollupOptions.input must be a single Chrome extension manifest.',
          )
        }

        const configResult = explorer.load(
          inputManifestPath,
        ); 





        if (configResult.isEmpty) {
          throw new Error(`${options.input} is an empty file.`)
        }

        manifestPath = configResult.filepath;
        cache.manifest = configResult.config;

        cache.srcDir = path.dirname(manifestPath);

        // Derive entry paths from manifest
        const { js, html, css, img, others } = deriveFiles(
          cache.manifest,
          cache.srcDir,
        );

        // Cache derived inputs
        cache.input = [...cache.inputAry, ...js, ...html];
        cache.assets = [
          // Dedupe assets
          ...new Set([...css, ...img, ...others]),
        ];

        /* --------------- END LOAD MANIFEST --------------- */
      }

      if (cache.input.length === 0) {
        throw new Error(
          'The manifest must have at least one script or HTML file.',
        )
      }

      // TODO: consider using this.emitFile in buildStart instead
      //  - the input record is unusual, but would this be more unusual?
      //  - would need to put something here, can't return an empty input
      //    - maybe a dummy file to remove in generateBundle?
      return {
        ...options,
        input: cache.input.reduce(
          reduceToRecord(cache.srcDir),
          cache.inputObj,
        ),
      }
    },

    /* ============================================ */
    /*              HANDLE WATCH FILES              */
    /* ============================================ */

    async buildStart() {
      this.addWatchFile(manifestPath);

      cache.assets.forEach((srcPath) => {
        this.addWatchFile(srcPath);
      });

      const assets = await Promise.all(
        cache.assets.map(async (srcPath) => {
          const source = await readAssetAsBuffer(srcPath);

          return {
            type: 'asset' ,
            source,
            fileName: path.relative(cache.srcDir, srcPath),
          }
        }),
      );

      assets.forEach((asset) => {
        this.emitFile(asset);
      });
    },

    watchChange(id) {
      if (id.endsWith(manifestName)) {
        // Dump cache.manifest if manifest changes
        delete cache.manifest;
        cache.assetChanged = false;
      } else {
        // Force new read of changed asset
        cache.assetChanged = cache.readFile.delete(id);
      }
    },

    /* ============================================ */
    /*                GENERATEBUNDLE                */
    /* ============================================ */

    generateBundle(options, bundle) {
      /* ---------- DERIVE PERMISIONS START --------- */

      // Get module ids for all chunks
      let permissions;
      if (cache.assetChanged && cache.permsHash) {
        // Permissions did not change
        permissions = JSON.parse(cache.permsHash); 

        cache.assetChanged = false;
      } else {
        const chunks = Object.values(bundle).filter(isChunk);

        // Permissions may have changed
        permissions = Array.from(
          chunks.reduce(derivePermissions, new Set()),
        );

        const permsHash = JSON.stringify(permissions);

        if (verbose) {
          if (!cache.permsHash) {
            this.warn(
              `Detected permissions: ${permissions.toString()}`,
            );
          } else if (permsHash !== cache.permsHash) {
            this.warn(
              `Detected new permissions: ${permissions.toString()}`,
            );
          }
        }

        cache.permsHash = permsHash;
      }

      /* ---------- DERIVE PERMISSIONS END ---------- */

      try {
        // Clone cache.manifest
        if (!cache.manifest)
          // This is a programming error, so it should throw
          throw new TypeError(
            `cache.manifest is ${typeof cache.manifest}`,
          )

        const clonedManifest = cloneObject(cache.manifest);

        const manifestBody = validateManifest({
          manifest_version: 2,
          name: pkg.name,
          version: pkg.version,
          description: pkg.description,
          ...clonedManifest,
          permissions: combinePerms(
            permissions,
            clonedManifest.permissions || [],
          ),
        });

        const {
          content_scripts: cts = [],
          web_accessible_resources: war = [],
          background: { scripts: bgs = [] } = {},
        } = manifestBody;

        /* ------------- SETUP CONTENT SCRIPTS ------------- */

        const contentScripts = cts.reduce(
          (r, { js = [] }) => [...r, ...js],
          [] ,
        );

        if (contentScripts.length) {
          const memoizedEmitter = memoize(
            (scriptPath) => {
              const source = code.replace(
                '%PATH%',
                // Fix path slashes to support Windows
                JSON.stringify(
                  slash(relative('assets', scriptPath)),
                ),
              );

              const assetId = this.emitFile({
                type: 'asset',
                source,
                name: basename(scriptPath),
              });

              return this.getFileName(assetId)
            },
          );

          // Setup content script import wrapper
          manifestBody.content_scripts = cts.map(
            ({ js, ...rest }) =>
              typeof js === 'undefined'
                ? rest
                : {
                    js: js
                      .map((p) => p.replace(/\.ts$/, '.js'))
                      .map(memoizedEmitter),
                    ...rest,
                  },
          );

          // make all imports & dynamic imports web_acc_res
          const imports = Object.values(bundle)
            .filter((x) => x.type === 'chunk')
            .reduce(
              (r, { isEntry, fileName }) =>
                // Get imported filenames
                !isEntry ? [...r, fileName] : r,
              [] ,
            );

          // SMELL: web accessible resources can be used for fingerprinting extensions
          manifestBody.web_accessible_resources = dedupe([
            ...war,
            // FEATURE: filter out imports for background?
            ...imports,
            // Need to be web accessible b/c of import
            ...contentScripts,
          ]);
        }

        /* ----------- END SETUP CONTENT SCRIPTS ----------- */

        /* ------------ SETUP BACKGROUND SCRIPTS ----------- */

        // Emit background script wrappers
        if (bgs.length && wrapperScript.length) {
          // background exists because bgs has scripts
          manifestBody.background.scripts = bgs
            // SMELL: is this replace necessary? are we doing somewhere else?
            .map((p) => p.replace(/\.ts$/, '.js'))
            .map((scriptPath) => {
              // Loader script exists because of type guard above
              const source =
                // Path to module being loaded
                wrapperScript.replace(
                  '%PATH%',
                  // Fix path slashes to support Windows
                  JSON.stringify(
                    slash(relative('assets', scriptPath)),
                  ),
                );

              const assetId = this.emitFile({
                type: 'asset',
                source,
                name: basename(scriptPath),
              });

              return this.getFileName(assetId)
            });
        }

        /* ---------- END SETUP BACKGROUND SCRIPTS --------- */

        /* --------- STABLE EXTENSION ID BEGIN -------- */

        if (publicKey) {
          manifestBody.key = publicKey;
        }

        /* ---------- STABLE EXTENSION ID END --------- */

        /* ----------- OUTPUT MANIFEST.JSON BEGIN ---------- */

        const manifestJson = JSON.stringify(
          manifestBody,
          null,
          2,
        )
          // SMELL: is this necessary?
          .replace(/\.[jt]sx?"/g, '.js"');

        // Emit manifest.json
        this.emitFile({
          type: 'asset',
          fileName: manifestName,
          source: manifestJson,
        });
      } catch (error) {
        // Catch here because we need the validated result in scope

        if (error.name !== 'ValidationError') throw error
        const errors = error.errors; 
        if (errors) {
          errors.forEach((err) => {
            // FIXME: make a better validation error message
            // https://github.com/atlassian/better-ajv-errors
            this.warn(JSON.stringify(err, undefined, 2));
          });
        }
        this.error(error.message);
      }

      /* ------------ OUTPUT MANIFEST.JSON END ----------- */
    },
  }
}

const validateNames = () => ({
  name: 'validate-names',

  generateBundle(options, bundle) {
    const chunks = Object.values(bundle).filter(
      (x) => x.type === 'chunk',
    );

    // Files cannot start with "_" in Chrome Extensions
    // Loop through each file and check for "_" in filename
    Object.keys(bundle)
      .filter((fileName) => fileName.startsWith('_'))
      .forEach((fileName) => {
        // Only replace first instance
        const regex = new RegExp(fileName);
        const fixed = fileName.slice(1);

        // Fix manifest
        const manifest = bundle['manifest.json']; 
        manifest.source = manifest.source.replace(regex, fixed);

        // Change bundle key
        const chunk = bundle[fileName];
        delete bundle[fileName];
        bundle[fixed] = chunk;

        // Fix chunk
        chunk.fileName = fixed;

        // Find imports and fix
        chunks
          .filter(({ imports }) => imports.includes(fileName))
          .forEach((chunk) => {
            // Fix imports list
            chunk.imports = chunk.imports.map((i) =>
              i === fileName ? fixed : i,
            );
            // Fix imports in code
            chunk.code = chunk.code.replace(regex, fixed);
          });
      });
  },
});

const code$3 = "(function () {\n  'use strict';\n\n  const timestampPathPlaceholder = '%TIMESTAMP_PATH%';\n  const loadMessagePlaceholder = '%LOAD_MESSAGE%';\n\n  /* eslint-env browser */\n\n  // Log load message to browser dev console\n  console.log(loadMessagePlaceholder.slice(1, -1));\n\n  let timestamp;\n\n  const id = setInterval(async () => {\n    const t = await fetch(timestampPathPlaceholder)\n      .then((res) => {\n        localStorage.removeItem('chromeExtensionReloaderErrors');\n        return res.json()\n      })\n      .catch(handleFetchError);\n\n    if (typeof timestamp === 'undefined') {\n      timestamp = t;\n    } else if (timestamp !== t) {\n      chrome.runtime.reload();\n    }\n\n    function handleFetchError(error) {\n      clearInterval(id);\n\n      const errors =\n        localStorage.chromeExtensionReloaderErrors || 0;\n\n      if (errors < 5) {\n        localStorage.chromeExtensionReloaderErrors = errors + 1;\n\n        // Should reload at least once if fetch fails.\n        // The fetch will fail if the timestamp file is absent,\n        // thus the new build does not include the reloader\n        return 0\n      } else {\n        console.log(\n          'rollup-plugin-chrome-extension simple reloader error:',\n        );\n        console.error(error);\n\n        return timestamp\n      }\n    }\n  }, 1000);\n\n}());\n";

const code$4 = "(function () {\n  'use strict';\n\n  const loadMessagePlaceholder = '%LOAD_MESSAGE%';\n\n  /* eslint-env browser */\n\n  // Log load message to browser dev console\n  console.log(loadMessagePlaceholder.slice(1, -1));\n\n  const { name } = chrome.runtime.getManifest();\n\n  const reload = () => {\n    console.log(`${name} has reloaded...`);\n\n    setTimeout(() => {\n      location.reload();\n    }, 500);\n  };\n\n  setInterval(() => {\n    try {\n      chrome.runtime.getManifest();\n    } catch (error) {\n      if (error.message === 'Extension context invalidated.') {\n        reload();\n      }\n    }\n  }, 1000);\n\n}());\n";

const backgroundPageReloader = 'background-page-reloader.js';
const contentScriptReloader = 'content-script-reloader.js';
const timestampFilename = 'timestamp.json';

const timestampPathPlaceholder = '%TIMESTAMP_PATH%';
const loadMessagePlaceholder = '%LOAD_MESSAGE%';

// Used for testing
const _internalCache = {};

const simpleReloader = (
  cache = {} ,
) => {
  if (!process.env.ROLLUP_WATCH) {
    return undefined
  }

  return {
    name: 'chrome-extension-simple-reloader',

    generateBundle({ dir }, bundle) {
      const date = new Date();
      const time = `${date
        .getFullYear()
        .toString()
        .padStart(2, '0')}-${(date.getMonth() + 1)
        .toString()
        .padStart(2, '0')}-${date
        .getDate()
        .toString()
        .padStart(2, '0')} ${date
        .getHours()
        .toString()
        .padStart(2, '0')}:${date
        .getMinutes()
        .toString()
        .padStart(2, '0')}:${date
        .getSeconds()
        .toString()
        .padStart(2, '0')}`;

      cache.outputDir = dir;
      cache.loadMessage = [
        'DEVELOPMENT build with simple auto-reloader',
        `[${time}] waiting for changes...`,
      ].join('\n');

      /* --------------- EMIT CLIENT FILES --------------- */

      const emit = (
        name,
        source,
        isFileName,
      ) => {
        const id = this.emitFile({
          type: 'asset',
          [isFileName ? 'fileName' : 'name']: name,
          source,
        });

        return this.getFileName(id)
      };

      cache.timestampPath = emit(
        timestampFilename,
        JSON.stringify(Date.now()),
        true,
      );

      cache.bgScriptPath = emit(
        backgroundPageReloader,
        code$3
          .replace(timestampPathPlaceholder, cache.timestampPath)
          .replace(
            loadMessagePlaceholder,
            JSON.stringify(cache.loadMessage),
          ),
      );

      cache.ctScriptPath = emit(
        contentScriptReloader,
        code$4.replace(
          loadMessagePlaceholder,
          JSON.stringify(cache.loadMessage),
        ),
      );

      // Update the exported cache
      Object.assign(_internalCache, cache);

      /* ---------------- UPDATE MANIFEST ---------------- */

      updateManifest(
        (manifest) => {
          /* ------------------ DESCRIPTION ------------------ */

          manifest.description = cache.loadMessage;

          /* ---------------- BACKGROUND PAGE ---------------- */

          if (!manifest.background) {
            manifest.background = {};
          }

          manifest.background.persistent = true;

          const { scripts: bgScripts = [] } = manifest.background;

          if (cache.bgScriptPath) {
            manifest.background.scripts = [
              cache.bgScriptPath,
              ...bgScripts,
            ];
          } else {
            this.error(
              `cache.bgScriptPath is ${typeof cache.bgScriptPath}`,
            );
          }

          /* ---------------- CONTENT SCRIPTS ---------------- */

          const { content_scripts: ctScripts = [] } = manifest;

          if (cache.ctScriptPath) {
            manifest.content_scripts = ctScripts.map(
              ({ js = [], ...rest }) => ({
                js: [cache.ctScriptPath, ...js],
                ...rest,
              }),
            );
          } else {
            this.error(
              `cache.ctScriptPath is ${typeof cache.ctScriptPath}`,
            );
          }

          return manifest
        },
        bundle,
        this.error,
      );

      // We'll write this file ourselves, we just need a safe path to write the timestamp
      delete bundle[cache.timestampPath];
    },

    /* -------------- WRITE TIMESTAMP FILE ------------- */
    async writeBundle() {
      try {
        await outputJson(
          join(cache.outputDir, cache.timestampPath),
          Date.now(),
        );
      } catch (err) {
        if (typeof err.message === 'string') {
          this.error(
            `Unable to update timestamp file:\n\t${err.message}`,
          );
        } else {
          this.error('Unable to update timestamp file');
        }
      }
    },
  }
};

const chromeExtension = (
  options = {} ,
) => {
  /* --------------- LOAD PACKAGE.JSON --------------- */

  try {
    const packageJsonPath = join(process.cwd(), 'package.json');
    options.pkg = options.pkg || readJSONSync(packageJsonPath);
  } catch (error) {}

  /* ----------------- SETUP PLUGINS ----------------- */

  const manifest = manifestInput(options);
  const html = htmlInputs(manifest);
  const validate = validateNames();

  /* ----------------- RETURN PLUGIN ----------------- */

  return {
    name: 'chrome-extension',

    // For testing
    _plugins: { manifest, html, validate },

    options(options) {
      try {
        return [manifest, html].reduce((opts, plugin) => {
          const result = plugin.options.call(this, opts);

          return result || options
        }, options)
      } catch (error) {
        const manifestError =
          'The manifest must have at least one script or HTML file.';
        const htmlError =
          'At least one HTML file must have at least one script.';

        if (
          error.message === manifestError ||
          error.message === htmlError
        ) {
          throw new Error(
            'A Chrome extension must have at least one script or HTML file.',
          )
        } else {
          throw error
        }
      }
    },

    async buildStart(options) {
      await Promise.all([
        manifest.buildStart.call(this, options),
        html.buildStart.call(this, options),
      ]);
    },

    watchChange(id) {
      manifest.watchChange.call(this, id);
      html.watchChange.call(this, id);
    },

    async generateBundle(...args) {
      await manifest.generateBundle.call(this, ...args);
      await validate.generateBundle.call(this, ...args);
    },
  }
};

export { chromeExtension, simpleReloader };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXgtZXNtLmpzIiwic291cmNlcyI6WyIuLi9zcmMvaGVscGVycy50cyIsIi4uL3NyYy9tYW5pZmVzdC1pbnB1dC9yZWR1Y2VUb1JlY29yZC50cyIsIi4uL3NyYy9odG1sLWlucHV0cy9jaGVlcmlvLnRzIiwiLi4vc3JjL2h0bWwtaW5wdXRzL2luZGV4LnRzIiwiLi4vc3JjL21hbmlmZXN0LWlucHV0L2R5bmFtaWNJbXBvcnRXcmFwcGVyLnRzIiwiLi4vc3JjL21hbmlmZXN0LWlucHV0L21hbmlmZXN0LXBhcnNlci9jb21iaW5lLnRzIiwiLi4vc3JjL21hbmlmZXN0LWlucHV0L21hbmlmZXN0LXBhcnNlci9wZXJtaXNzaW9ucy50cyIsIi4uL3NyYy9tYW5pZmVzdC1pbnB1dC9tYW5pZmVzdC1wYXJzZXIvaW5kZXgudHMiLCIuLi9zcmMvbWFuaWZlc3QtaW5wdXQvbWFuaWZlc3QtcGFyc2VyL3ZhbGlkYXRlLnRzIiwiLi4vc3JjL21hbmlmZXN0LWlucHV0L2luZGV4LnRzIiwiLi4vc3JjL3ZhbGlkYXRlLW5hbWVzL2luZGV4LnRzIiwiLi4vc3JjL3BsdWdpbi1yZWxvYWRlci1zaW1wbGUvQ09OU1RBTlRTLnRzIiwiLi4vc3JjL3BsdWdpbi1yZWxvYWRlci1zaW1wbGUvaW5kZXgudHMiLCIuLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3V0cHV0QXNzZXQsIE91dHB1dENodW5rLCBPdXRwdXRCdW5kbGUgfSBmcm9tICdyb2xsdXAnXG5pbXBvcnQgcHJldHRpZXIgZnJvbSAncHJldHRpZXInXG5pbXBvcnQgeyBDaGVlcmlvRmlsZSB9IGZyb20gJy4vaHRtbC1pbnB1dHMnXG5pbXBvcnQgeyBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCB9IGZyb20gJy4vbWFuaWZlc3QnXG5cbmV4cG9ydCBjb25zdCBub3QgPSA8VD4oZm46ICh4OiBUKSA9PiBib29sZWFuKSA9PiAoeDogVCkgPT4gIWZuKHgpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NodW5rKFxuICB4OiBPdXRwdXRDaHVuayB8IE91dHB1dEFzc2V0LFxuKTogeCBpcyBPdXRwdXRDaHVuayB7XG4gIHJldHVybiB4LnR5cGUgPT09ICdjaHVuaydcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXNzZXQoXG4gIHg6IE91dHB1dENodW5rIHwgT3V0cHV0QXNzZXQsXG4pOiB4IGlzIE91dHB1dENodW5rIHtcbiAgcmV0dXJuIHgudHlwZSA9PT0gJ2Fzc2V0J1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcoeDogYW55KTogeCBpcyBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0pzb25GaWxlUGF0aCh4OiBhbnkpOiB4IGlzIHN0cmluZyB7XG4gIHJldHVybiBpc1N0cmluZyh4KSAmJiB4LmVuZHNXaXRoKCdqc29uJylcbn1cblxuZXhwb3J0IGNvbnN0IGZvcm1hdEh0bWwgPSAoJDogQ2hlZXJpb0ZpbGUpID0+XG4gIHByZXR0aWVyLmZvcm1hdCgkLmh0bWwoKSwgeyBwYXJzZXI6ICdodG1sJyB9KVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgbWFuaWZlc3Qgc291cmNlIGluIHRoZSBvdXRwdXQgYnVuZGxlXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVNYW5pZmVzdCA9IChcbiAgdXBkYXRlcjogKFxuICAgIG1hbmlmZXN0OiBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCxcbiAgKSA9PiBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCxcbiAgYnVuZGxlOiBPdXRwdXRCdW5kbGUsXG4gIGhhbmRsZUVycm9yPzogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCxcbik6IE91dHB1dEJ1bmRsZSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWFuaWZlc3RLZXkgPSAnbWFuaWZlc3QuanNvbidcbiAgICBjb25zdCBtYW5pZmVzdEFzc2V0ID0gYnVuZGxlW21hbmlmZXN0S2V5XSBhcyBPdXRwdXRBc3NldFxuXG4gICAgaWYgKCFtYW5pZmVzdEFzc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdObyBtYW5pZmVzdC5qc29uIGluIHRoZSByb2xsdXAgb3V0cHV0IGJ1bmRsZS4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IG1hbmlmZXN0ID0gSlNPTi5wYXJzZShcbiAgICAgIG1hbmlmZXN0QXNzZXQuc291cmNlIGFzIHN0cmluZyxcbiAgICApIGFzIENocm9tZUV4dGVuc2lvbk1hbmlmZXN0XG5cbiAgICBjb25zdCByZXN1bHQgPSB1cGRhdGVyKG1hbmlmZXN0KVxuXG4gICAgbWFuaWZlc3RBc3NldC5zb3VyY2UgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQsIHVuZGVmaW5lZCwgMilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaGFuZGxlRXJyb3IpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVycm9yLm1lc3NhZ2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1bmRsZVxufVxuIiwiaW1wb3J0IHsgcmVsYXRpdmUgfSBmcm9tICdwYXRoJ1xuXG50eXBlIElucHV0UmVjb3JkID0gUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlVG9SZWNvcmQoc3JjRGlyOiBzdHJpbmcgfCBudWxsKSB7XG4gIGlmIChzcmNEaXIgPT09IG51bGwgfHwgdHlwZW9mIHNyY0RpciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBUaGlzIHdvdWxkIGJlIGEgY29uZmlnIGVycm9yLCBzbyBzaG91bGQgdGhyb3dcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzcmNEaXIgaXMgbnVsbCBvciB1bmRlZmluZWQnKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpbnB1dFJlY29yZDogSW5wdXRSZWNvcmQsXG4gICAgZmlsZW5hbWU6IHN0cmluZyxcbiAgKTogSW5wdXRSZWNvcmQgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSByZWxhdGl2ZShzcmNEaXIsIGZpbGVuYW1lKVxuICAgICAgLnNwbGl0KCcuJylcbiAgICAgIC5zbGljZSgwLCAtMSlcbiAgICAgIC5qb2luKCcuJylcblxuICAgIGlmIChuYW1lIGluIGlucHV0UmVjb3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBTY3JpcHQgZmlsZXMgd2l0aCBkaWZmZXJlbnQgZXh0ZW5zaW9ucyBzaG91bGQgbm90IHNoYXJlIG5hbWVzOlxcblxcblwiJHtmaWxlbmFtZX1cIlxcbndpbGwgb3ZlcndyaXRlXFxuXCIke2lucHV0UmVjb3JkW25hbWVdfVwiYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4geyAuLi5pbnB1dFJlY29yZCwgW25hbWVdOiBmaWxlbmFtZSB9XG4gIH1cbn1cbiIsImltcG9ydCBjaGVlcmlvIGZyb20gJ2NoZWVyaW8nXG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuLi9oZWxwZXJzJ1xuXG5leHBvcnQgY29uc3QgbG9hZEh0bWwgPSAoZmlsZVBhdGg6IHN0cmluZykgPT4ge1xuICBjb25zdCBodG1sQ29kZSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKVxuICBjb25zdCAkID0gY2hlZXJpby5sb2FkKGh0bWxDb2RlKVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKCQsIHsgZmlsZVBhdGggfSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldFJlbGF0aXZlUGF0aCA9IChmaWxlUGF0aDogc3RyaW5nKSA9PiAoXG4gIHA6IHN0cmluZyxcbikgPT4ge1xuICBjb25zdCBmaWxlRGlyID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKVxuICBjb25zdCByZWxEaXIgPSBwYXRoLnJlbGF0aXZlKHByb2Nlc3MuY3dkKCksIGZpbGVEaXIpXG5cbiAgcmV0dXJuIHBhdGguam9pbihyZWxEaXIsIHApXG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFNDUklQVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuZXhwb3J0IGNvbnN0IGdldFNjcmlwdEVsZW1zID0gKCQ6IENoZWVyaW9TdGF0aWMpID0+XG4gICQoJ3NjcmlwdCcpXG4gICAgLm5vdCgnW2RhdGEtcm9sbHVwLWFzc2V0XScpXG4gICAgLm5vdCgnW3NyY149XCJodHRwOlwiXScpXG4gICAgLm5vdCgnW3NyY149XCJodHRwczpcIl0nKVxuICAgIC5ub3QoJ1tzcmNePVwiZGF0YTpcIl0nKVxuICAgIC5ub3QoJ1tzcmNePVwiL1wiXScpXG5cbi8vIE11dGF0aXZlIGFjdGlvblxuZXhwb3J0IGNvbnN0IG11dGF0ZVNjcmlwdEVsZW1zID0gKFxuICAkOiBDaGVlcmlvU3RhdGljICYge1xuICAgIGZpbGVQYXRoOiBzdHJpbmdcbiAgfSxcbikgPT4ge1xuICBnZXRTY3JpcHRFbGVtcygkKVxuICAgIC5hdHRyKCd0eXBlJywgJ21vZHVsZScpXG4gICAgLmF0dHIoJ3NyYycsIChpLCB2YWx1ZSkgPT4ge1xuICAgICAgLy8gRklYTUU6IEB0eXBlcy9jaGVlcmlvIGlzIHdyb25nIGZvciBBdHRyRnVuY3Rpb246IGluZGV4LmQudHMsIGxpbmUgMTZcbiAgICAgIC8vIGRlY2xhcmUgdHlwZSBBdHRyRnVuY3Rpb24gPSAoaTogbnVtYmVyLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gYW55O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCByZXBsYWNlZCA9IHZhbHVlLnJlcGxhY2UoL1xcLltqdF1zeD8vZywgJy5qcycpXG5cbiAgICAgIHJldHVybiByZXBsYWNlZFxuICAgIH0pXG5cbiAgcmV0dXJuICRcbn1cblxuZXhwb3J0IGNvbnN0IGdldFNjcmlwdHMgPSAoJDogQ2hlZXJpb1N0YXRpYykgPT5cbiAgZ2V0U2NyaXB0RWxlbXMoJCkudG9BcnJheSgpXG5cbmV4cG9ydCBjb25zdCBnZXRTY3JpcHRTcmMgPSAoXG4gICQ6IENoZWVyaW9TdGF0aWMgJiB7XG4gICAgZmlsZVBhdGg6IHN0cmluZ1xuICB9LFxuKSA9PlxuICBnZXRTY3JpcHRzKCQpXG4gICAgLm1hcCgoZWxlbSkgPT4gJChlbGVtKS5hdHRyKCdzcmMnKSlcbiAgICAuZmlsdGVyKGlzU3RyaW5nKVxuICAgIC5tYXAoZ2V0UmVsYXRpdmVQYXRoKCQuZmlsZVBhdGgpKVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLSBBU1NFVCBTQ1JJUFRTIC0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmNvbnN0IGdldEFzc2V0cyA9ICgkOiBDaGVlcmlvU3RhdGljKSA9PlxuICAkKCdzY3JpcHQnKVxuICAgIC5maWx0ZXIoJ1tkYXRhLXJvbGx1cC1hc3NldD1cInRydWVcIl0nKVxuICAgIC5ub3QoJ1tzcmNePVwiaHR0cDpcIl0nKVxuICAgIC5ub3QoJ1tzcmNePVwiaHR0cHM6XCJdJylcbiAgICAubm90KCdbc3JjXj1cImRhdGE6XCJdJylcbiAgICAubm90KCdbc3JjXj1cIi9cIl0nKVxuICAgIC50b0FycmF5KClcblxuZXhwb3J0IGNvbnN0IGdldEpzQXNzZXRzID0gKFxuICAkOiBDaGVlcmlvU3RhdGljICYge1xuICAgIGZpbGVQYXRoOiBzdHJpbmdcbiAgfSxcbikgPT5cbiAgZ2V0QXNzZXRzKCQpXG4gICAgLm1hcCgoZWxlbSkgPT4gJChlbGVtKS5hdHRyKCdzcmMnKSlcbiAgICAuZmlsdGVyKGlzU3RyaW5nKVxuICAgIC5tYXAoZ2V0UmVsYXRpdmVQYXRoKCQuZmlsZVBhdGgpKVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSBjc3MgLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5jb25zdCBnZXRDc3MgPSAoJDogQ2hlZXJpb1N0YXRpYykgPT5cbiAgJCgnbGluaycpXG4gICAgLmZpbHRlcignW3JlbD1cInN0eWxlc2hlZXRcIl0nKVxuICAgIC5ub3QoJ1tocmVmXj1cImh0dHA6XCJdJylcbiAgICAubm90KCdbaHJlZl49XCJodHRwczpcIl0nKVxuICAgIC5ub3QoJ1tocmVmXj1cImRhdGE6XCJdJylcbiAgICAubm90KCdbaHJlZl49XCIvXCJdJylcbiAgICAudG9BcnJheSgpXG5cbmV4cG9ydCBjb25zdCBnZXRDc3NIcmVmcyA9IChcbiAgJDogQ2hlZXJpb1N0YXRpYyAmIHtcbiAgICBmaWxlUGF0aDogc3RyaW5nXG4gIH0sXG4pID0+XG4gIGdldENzcygkKVxuICAgIC5tYXAoKGVsZW0pID0+ICQoZWxlbSkuYXR0cignaHJlZicpKVxuICAgIC5maWx0ZXIoaXNTdHJpbmcpXG4gICAgLm1hcChnZXRSZWxhdGl2ZVBhdGgoJC5maWxlUGF0aCkpXG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tIGltZyAtLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmNvbnN0IGdldEltZ3MgPSAoJDogQ2hlZXJpb1N0YXRpYykgPT5cbiAgJCgnaW1nJylcbiAgICAubm90KCdbc3JjXj1cImh0dHA6Ly9cIl0nKVxuICAgIC5ub3QoJ1tzcmNePVwiaHR0cHM6Ly9cIl0nKVxuICAgIC5ub3QoJ1tzcmNePVwiZGF0YTpcIl0nKVxuICAgIC5ub3QoJ1tzcmNePVwiL1wiXScpXG4gICAgLnRvQXJyYXkoKVxuXG5jb25zdCBnZXRGYXZpY29ucyA9ICgkOiBDaGVlcmlvU3RhdGljKSA9PlxuICAkKCdsaW5rW3JlbD1cImljb25cIl0nKVxuICAgIC5ub3QoJ1tocmVmXj1cImh0dHA6XCJdJylcbiAgICAubm90KCdbaHJlZl49XCJodHRwczpcIl0nKVxuICAgIC5ub3QoJ1tocmVmXj1cImRhdGE6XCJdJylcbiAgICAubm90KCdbaHJlZl49XCIvXCJdJylcbiAgICAudG9BcnJheSgpXG5cbmV4cG9ydCBjb25zdCBnZXRJbWdTcmNzID0gKFxuICAkOiBDaGVlcmlvU3RhdGljICYge1xuICAgIGZpbGVQYXRoOiBzdHJpbmdcbiAgfSxcbikgPT4ge1xuICByZXR1cm4gW1xuICAgIC4uLmdldEltZ3MoJCkubWFwKChlbGVtKSA9PiAkKGVsZW0pLmF0dHIoJ3NyYycpKSxcbiAgICAuLi5nZXRGYXZpY29ucygkKS5tYXAoKGVsZW0pID0+ICQoZWxlbSkuYXR0cignaHJlZicpKSxcbiAgXVxuICAgIC5maWx0ZXIoaXNTdHJpbmcpXG4gICAgLm1hcChnZXRSZWxhdGl2ZVBhdGgoJC5maWxlUGF0aCkpXG59XG4iLCJpbXBvcnQgJ2FycmF5LWZsYXQtcG9seWZpbGwnXG5pbXBvcnQgeyByZWFkRmlsZSB9IGZyb20gJ2ZzLWV4dHJhJ1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSAnbG9kYXNoLmZsYXR0ZW4nXG5pbXBvcnQgeyByZWxhdGl2ZSB9IGZyb20gJ3BhdGgnXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdyb2xsdXAnXG5pbXBvcnQgeyBmb3JtYXRIdG1sLCBub3QgfSBmcm9tICcuLi9oZWxwZXJzJ1xuaW1wb3J0IHsgcmVkdWNlVG9SZWNvcmQgfSBmcm9tICcuLi9tYW5pZmVzdC1pbnB1dC9yZWR1Y2VUb1JlY29yZCdcbmltcG9ydCB7XG4gIGdldENzc0hyZWZzLFxuICBnZXRJbWdTcmNzLFxuICBnZXRKc0Fzc2V0cyxcbiAgZ2V0U2NyaXB0U3JjLFxuICBsb2FkSHRtbCxcbiAgbXV0YXRlU2NyaXB0RWxlbXMsXG59IGZyb20gJy4vY2hlZXJpbydcblxuLyoqIENoZWVyaW9TdGF0aWMgb2JqZWN0cyB3aXRoIGEgZmlsZSBwYXRoICovXG5leHBvcnQgdHlwZSBDaGVlcmlvRmlsZSA9IENoZWVyaW9TdGF0aWMgJiB7XG4gIGZpbGVQYXRoOiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIdG1sSW5wdXRzT3B0aW9ucyB7XG4gIC8qKiBUaGlzIHdpbGwgY2hhbmdlIGJldHdlZW4gYnVpbGRzLCBzbyBjYW5ub3QgZGVzdHJ1Y3R1cmUgKi9cbiAgcmVhZG9ubHkgc3JjRGlyOiBzdHJpbmcgfCBudWxsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSHRtbElucHV0c1BsdWdpbkNhY2hlIHtcbiAgLyoqIFNjcmlwdHMgdGhhdCBzaG91bGQgbm90IGJlIGJ1bmRsZWQgKi9cbiAgc2NyaXB0czogc3RyaW5nW11cbiAgLyoqIFNjcmlwdHMgdGhhdCBzaG91bGQgYmUgYnVuZGxlZCAqL1xuICBqczogc3RyaW5nW11cbiAgLyoqIEFic29sdXRlIHBhdGhzIGZvciBIVE1MIGZpbGVzIHRvIGVtaXQgKi9cbiAgaHRtbDogc3RyaW5nW11cbiAgLyoqIEh0bWwgZmlsZXMgYXMgQ2hlZXJpbyBvYmplY3RzICovXG4gIGh0bWwkOiBDaGVlcmlvRmlsZVtdXG4gIC8qKiBJbWFnZSBmaWxlcyB0byBlbWl0ICovXG4gIGltZzogc3RyaW5nW11cbiAgLyoqIFN0eWxlc2hlZXRzIHRvIGVtaXQgKi9cbiAgY3NzOiBzdHJpbmdbXVxuICAvKiogQ2FjaGUgb2YgbGFzdCBvcHRpb25zLmlucHV0LCB3aWxsIGhhdmUgb3RoZXIgc2NyaXB0cyAqL1xuICBpbnB1dDogc3RyaW5nW11cbiAgLyoqIFNvdXJjZSBkaXIgZm9yIGNhbGN1bGF0aW5nIHJlbGF0aXZlIHBhdGhzICovXG4gIHNyY0Rpcj86IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBIdG1sSW5wdXRzUGx1Z2luID0gUGljazxcbiAgUmVxdWlyZWQ8UGx1Z2luPixcbiAgJ25hbWUnIHwgJ29wdGlvbnMnIHwgJ2J1aWxkU3RhcnQnIHwgJ3dhdGNoQ2hhbmdlJ1xuPiAmIHsgY2FjaGU6IEh0bWxJbnB1dHNQbHVnaW5DYWNoZSB9XG5cbmNvbnN0IGlzSHRtbCA9IChwYXRoOiBzdHJpbmcpID0+IC9cXC5odG1sPyQvLnRlc3QocGF0aClcblxuY29uc3QgbmFtZSA9ICdodG1sLWlucHV0cydcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qICAgICAgICAgICAgICAgICAgSFRNTC1JTlBVVFMgICAgICAgICAgICAgICAgICovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBodG1sSW5wdXRzKFxuICBodG1sSW5wdXRzT3B0aW9uczogSHRtbElucHV0c09wdGlvbnMsXG4gIC8qKiBVc2VkIGZvciB0ZXN0aW5nICovXG4gIGNhY2hlID0ge1xuICAgIHNjcmlwdHM6IFtdLFxuICAgIGh0bWw6IFtdLFxuICAgIGh0bWwkOiBbXSxcbiAgICBqczogW10sXG4gICAgY3NzOiBbXSxcbiAgICBpbWc6IFtdLFxuICAgIGlucHV0OiBbXSxcbiAgfSBhcyBIdG1sSW5wdXRzUGx1Z2luQ2FjaGUsXG4pOiBIdG1sSW5wdXRzUGx1Z2luIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIGNhY2hlLFxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgICAvKiAgICAgICAgICAgICAgICAgT1BUSU9OUyBIT09LICAgICAgICAgICAgICAgICAqL1xuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIC8vIFNraXAgaWYgY2FjaGUuaW5wdXQgZXhpc3RzXG4gICAgICAvLyBjYWNoZSBpcyBkdW1wZWQgaW4gd2F0Y2hDaGFuZ2UgaG9va1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zLmlucHV0IHRvIGFycmF5XG4gICAgICBsZXQgaW5wdXQ6IHN0cmluZ1tdXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlucHV0ID0gW29wdGlvbnMuaW5wdXRdXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnB1dCkpIHtcbiAgICAgICAgaW5wdXQgPSBbLi4ub3B0aW9ucy5pbnB1dF1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlucHV0ID0gT2JqZWN0LnZhbHVlcyhvcHRpb25zLmlucHV0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgb3B0aW9ucy5pbnB1dCBjYW5ub3QgYmUgJHt0eXBlb2Ygb3B0aW9ucy5pbnB1dH1gLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgIC8qICAgICAgICAgICAgICAgICBIQU5ETEUgSFRNTCBGSUxFUyAgICAgICAgICAgICAgICAgKi9cbiAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgLy8gRmlsdGVyIGh0bSBhbmQgaHRtbCBmaWxlc1xuICAgICAgY2FjaGUuaHRtbCA9IGlucHV0LmZpbHRlcihpc0h0bWwpXG5cbiAgICAgIC8vIElmIG5vIGh0bWwgZmlsZXMsIGRvIG5vdGhpbmdcbiAgICAgIGlmIChjYWNoZS5odG1sLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG9wdGlvbnNcblxuICAgICAgLy8gSWYgdGhlIGNhY2hlIGhhcyBiZWVuIGR1bXBlZCwgcmVsb2FkIGZyb20gZmlsZXNcbiAgICAgIGlmIChjYWNoZS5odG1sJC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbGwgZG9uZSBvbmNlXG4gICAgICAgIGNhY2hlLmh0bWwkID0gY2FjaGUuaHRtbC5tYXAobG9hZEh0bWwpXG5cbiAgICAgICAgY2FjaGUuanMgPSBmbGF0dGVuKGNhY2hlLmh0bWwkLm1hcChnZXRTY3JpcHRTcmMpKVxuICAgICAgICBjYWNoZS5jc3MgPSBmbGF0dGVuKGNhY2hlLmh0bWwkLm1hcChnZXRDc3NIcmVmcykpXG4gICAgICAgIGNhY2hlLmltZyA9IGZsYXR0ZW4oY2FjaGUuaHRtbCQubWFwKGdldEltZ1NyY3MpKVxuICAgICAgICBjYWNoZS5zY3JpcHRzID0gZmxhdHRlbihjYWNoZS5odG1sJC5tYXAoZ2V0SnNBc3NldHMpKVxuXG4gICAgICAgIC8vIENhY2hlIGpzRW50cmllcyB3aXRoIGV4aXN0aW5nIG9wdGlvbnMuaW5wdXRcbiAgICAgICAgY2FjaGUuaW5wdXQgPSBpbnB1dC5maWx0ZXIobm90KGlzSHRtbCkpLmNvbmNhdChjYWNoZS5qcylcblxuICAgICAgICAvLyBQcmVwYXJlIGNhY2hlLmh0bWwkIGZvciBhc3NldCBlbWlzc2lvblxuICAgICAgICBjYWNoZS5odG1sJC5mb3JFYWNoKG11dGF0ZVNjcmlwdEVsZW1zKVxuXG4gICAgICAgIGlmIChjYWNoZS5pbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQXQgbGVhc3Qgb25lIEhUTUwgZmlsZSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHNjcmlwdC4nLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBzaW1wbHkgcmVtb3ZlIEhUTUwgZmlsZXMgZnJvbSBvcHRpb25zLmlucHV0XG4gICAgICAvLyAtIFBhcnNlIEhUTUwgYW5kIGVtaXQgY2h1bmtzIGFuZCBhc3NldHMgaW4gYnVpbGRTdGFydFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaW5wdXQ6IGNhY2hlLmlucHV0LnJlZHVjZShcbiAgICAgICAgICByZWR1Y2VUb1JlY29yZChodG1sSW5wdXRzT3B0aW9ucy5zcmNEaXIpLFxuICAgICAgICAgIHt9LFxuICAgICAgICApLFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAgIC8qICAgICAgICAgICAgICBIQU5ETEUgRklMRSBDSEFOR0VTICAgICAgICAgICAgICovXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIGFzeW5jIGJ1aWxkU3RhcnQoKSB7XG4gICAgICBjb25zdCB7IHNyY0RpciB9ID0gaHRtbElucHV0c09wdGlvbnNcblxuICAgICAgaWYgKHNyY0Rpcikge1xuICAgICAgICBjYWNoZS5zcmNEaXIgPSBzcmNEaXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuc3JjRGlyIG5vdCBpbml0aWFsaXplZCcpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFzc2V0cyA9IFtcbiAgICAgICAgLi4uY2FjaGUuY3NzLFxuICAgICAgICAuLi5jYWNoZS5pbWcsXG4gICAgICAgIC4uLmNhY2hlLnNjcmlwdHMsXG4gICAgICBdXG5cbiAgICAgIGFzc2V0cy5jb25jYXQoY2FjaGUuaHRtbCkuZm9yRWFjaCgoYXNzZXQpID0+IHtcbiAgICAgICAgdGhpcy5hZGRXYXRjaEZpbGUoYXNzZXQpXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBlbWl0dGluZyA9IGFzc2V0cy5tYXAoYXN5bmMgKGFzc2V0KSA9PiB7XG4gICAgICAgIC8vIFJlYWQgdGhlc2UgZmlsZXMgYXMgQnVmZmVyc1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBhd2FpdCByZWFkRmlsZShhc3NldClcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSByZWxhdGl2ZShzcmNEaXIsIGFzc2V0KVxuXG4gICAgICAgIHRoaXMuZW1pdEZpbGUoe1xuICAgICAgICAgIHR5cGU6ICdhc3NldCcsXG4gICAgICAgICAgc291cmNlLCAvLyBCdWZmZXJcbiAgICAgICAgICBmaWxlTmFtZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIGNhY2hlLmh0bWwkLm1hcCgoJCkgPT4ge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBmb3JtYXRIdG1sKCQpXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcmVsYXRpdmUoc3JjRGlyLCAkLmZpbGVQYXRoKVxuXG4gICAgICAgIHRoaXMuZW1pdEZpbGUoe1xuICAgICAgICAgIHR5cGU6ICdhc3NldCcsXG4gICAgICAgICAgc291cmNlLCAvLyBTdHJpbmdcbiAgICAgICAgICBmaWxlTmFtZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGVtaXR0aW5nKVxuICAgIH0sXG5cbiAgICB3YXRjaENoYW5nZShpZCkge1xuICAgICAgaWYgKGlkLmVuZHNXaXRoKCcuaHRtbCcpIHx8IGlkLmVuZHNXaXRoKCdtYW5pZmVzdC5qc29uJykpIHtcbiAgICAgICAgLy8gRHVtcCBjYWNoZSBpZiBodG1sIGZpbGUgb3IgbWFuaWZlc3QgY2hhbmdlc1xuICAgICAgICBjYWNoZS5odG1sJCA9IFtdXG4gICAgICB9XG4gICAgfSxcbiAgfVxufVxuIiwiaW1wb3J0IHsgY29kZSBhcyBleHBsaWNpdFNjcmlwdCB9IGZyb20gJ2NvZGUgLi9icm93c2VyL2ltcG9ydFdyYXBwZXItLWV4cGxpY2l0LnRzJ1xuaW1wb3J0IHsgY29kZSBhcyBpbXBsaWNpdFNjcmlwdCB9IGZyb20gJ2NvZGUgLi9icm93c2VyL2ltcG9ydFdyYXBwZXItLWltcGxpY2l0LnRzJ1xuXG4vKipcbiAqIFRoaXMgb3B0aW9ucyBvYmplY3QgYWxsb3dzIGZpbmUtdHVuaW5nIG9mIHRoZSBkeW5hbWljIGltcG9ydCB3cmFwcGVyLlxuICpcbiAqIEBleHBvcnRcbiAqIEBpbnRlcmZhY2UgRHluYW1pY0ltcG9ydFdyYXBwZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEeW5hbWljSW1wb3J0V3JhcHBlck9wdGlvbnMge1xuICAvKiogSG93IGxvbmcgdG8gZGVsYXkgd2FrZSBldmVudHMgYWZ0ZXIgZHluYW1pYyBpbXBvcnQgaGFzIGNvbXBsZXRlZCAqL1xuICBldmVudERlbGF5PzogbnVtYmVyXG4gIC8qKiBMaW1pdCB3aGljaCB3YWtlIGV2ZW50cyB0byBjYXB0dXJlLiBVc2UgaWYgdGhlIGRlZmF1bHQgZXZlbnQgZGlzY292ZXJ5IGlzIHRvbyBzbG93LiAqL1xuICB3YWtlRXZlbnRzPzogc3RyaW5nW11cbiAgLyoqIEFQSSBuYW1lc3BhY2VzIHRvIGV4Y2x1ZGUgZnJvbSBhdXRvbWF0aWMgZGV0ZWN0aW9uICovXG4gIGV4Y2x1ZGVOYW1lcz86IHN0cmluZ1tdXG59XG5cbi8vIEZFQVRVUkU6IGFkZCBzdGF0aWMgY29kZSBhbmFseXNpcyBmb3Igd2FrZSBldmVudHNcbi8vICAtIFRoaXMgd2lsbCBiZSBzbG93ZXIuLi5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwSW1wb3J0V3JhcHBlclNjcmlwdCh7XG4gIGV2ZW50RGVsYXkgPSAwLFxuICB3YWtlRXZlbnRzID0gW10sXG4gIGV4Y2x1ZGVOYW1lcyA9IFsnZXh0ZW5zaW9uJ10sXG59OiBEeW5hbWljSW1wb3J0V3JhcHBlck9wdGlvbnMpIHtcbiAgY29uc3QgZGVsYXkgPSBKU09OLnN0cmluZ2lmeShldmVudERlbGF5KVxuICBjb25zdCBldmVudHMgPSB3YWtlRXZlbnRzLmxlbmd0aFxuICAgID8gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHdha2VFdmVudHMubWFwKChldikgPT4gZXYucmVwbGFjZSgvXmNocm9tZVxcLi8sICcnKSksXG4gICAgICApXG4gICAgOiBmYWxzZVxuICBjb25zdCBleGNsdWRlID0gSlNPTi5zdHJpbmdpZnkoZXhjbHVkZU5hbWVzKVxuXG4gIGNvbnN0IHNjcmlwdCA9IChldmVudHNcbiAgICA/IGV4cGxpY2l0U2NyaXB0LnJlcGxhY2UoJyVFVkVOVFMlJywgZXZlbnRzKVxuICAgIDogaW1wbGljaXRTY3JpcHQucmVwbGFjZSgnJUVYQ0xVREUlJywgZXhjbHVkZSlcbiAgKS5yZXBsYWNlKCclREVMQVklJywgZGVsYXkpXG5cbiAgcmV0dXJuIHNjcmlwdFxufVxuIiwiaW1wb3J0ICdhcnJheS1mbGF0LXBvbHlmaWxsJ1xuXG5leHBvcnQgY29uc3QgY29tYmluZVBlcm1zID0gKFxuICAuLi5wZXJtaXNzaW9uczogc3RyaW5nW10gfCBzdHJpbmdbXVtdXG4pOiBzdHJpbmdbXSA9PiB7XG4gIGNvbnN0IHsgcGVybXMsIHhwZXJtcyB9ID0gKHBlcm1pc3Npb25zLmZsYXQoXG4gICAgSW5maW5pdHksXG4gICkgYXMgc3RyaW5nW10pXG4gICAgLmZpbHRlcigocGVybSkgPT4gdHlwZW9mIHBlcm0gIT09ICd1bmRlZmluZWQnKVxuICAgIC5yZWR1Y2UoXG4gICAgICAoeyBwZXJtcywgeHBlcm1zIH0sIHBlcm0pID0+IHtcbiAgICAgICAgaWYgKHBlcm0uc3RhcnRzV2l0aCgnIScpKSB7XG4gICAgICAgICAgeHBlcm1zLmFkZChwZXJtLnNsaWNlKDEpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlcm1zLmFkZChwZXJtKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcGVybXMsIHhwZXJtcyB9XG4gICAgICB9LFxuICAgICAgeyBwZXJtczogbmV3IFNldDxzdHJpbmc+KCksIHhwZXJtczogbmV3IFNldDxzdHJpbmc+KCkgfSxcbiAgICApXG5cbiAgcmV0dXJuIFsuLi5wZXJtc10uZmlsdGVyKChwKSA9PiAheHBlcm1zLmhhcyhwKSlcbn1cbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKiAgICAgICAgICAgICAgIENIRUNLIFBFUk1JU1NJT05TICAgICAgICAgICAgICAqL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLy8gZXhwb3J0IGNvbnN0IGRlYnVnZ2VyID0gcyA9PiAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSpkZWJ1Z2dlci8udGVzdChzKVxuLy8gZXhwb3J0IGNvbnN0IGVudGVycHJpc2UuZGV2aWNlQXR0cmlidXRlcyA9IHMgPT4gL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qZW50ZXJwcmlzZVxcLmRldmljZUF0dHJpYnV0ZXMvLnRlc3Qocylcbi8vIGV4cG9ydCBjb25zdCBlbnRlcnByaXNlLmhhcmR3YXJlUGxhdGZvcm0gPSBzID0+IC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmVudGVycHJpc2VcXC5oYXJkd2FyZVBsYXRmb3JtLy50ZXN0KHMpXG4vLyBleHBvcnQgY29uc3QgZW50ZXJwcmlzZS5wbGF0Zm9ybUtleXMgPSBzID0+IC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmVudGVycHJpc2VcXC5wbGF0Zm9ybUtleXMvLnRlc3Qocylcbi8vIGV4cG9ydCBjb25zdCBuZXR3b3JraW5nLmNvbmZpZyA9IHMgPT4gL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qbmV0d29ya2luZ1xcLmNvbmZpZy8udGVzdChzKVxuLy8gZXhwb3J0IGNvbnN0IHN5c3RlbS5jcHUgPSBzID0+IC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKnN5c3RlbVxcLmNwdS8udGVzdChzKVxuLy8gZXhwb3J0IGNvbnN0IHN5c3RlbS5kaXNwbGF5ID0gcyA9PiAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSpzeXN0ZW1cXC5kaXNwbGF5Ly50ZXN0KHMpXG4vLyBleHBvcnQgY29uc3Qgc3lzdGVtLm1lbW9yeSA9IHMgPT4gL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qc3lzdGVtXFwubWVtb3J5Ly50ZXN0KHMpXG4vLyBleHBvcnQgY29uc3Qgc3lzdGVtLnN0b3JhZ2UgPSBzID0+IC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKnN5c3RlbVxcLnN0b3JhZ2UvLnRlc3QocylcblxuZXhwb3J0IGNvbnN0IGFsYXJtcyA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmFsYXJtcy8udGVzdChzKVxuXG5leHBvcnQgY29uc3QgYm9va21hcmtzID0gKHM6IHN0cmluZykgPT5cbiAgL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qYm9va21hcmtzLy50ZXN0KHMpXG5cbmV4cG9ydCBjb25zdCBjb250ZW50U2V0dGluZ3MgPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSpjb250ZW50U2V0dGluZ3MvLnRlc3QocylcblxuZXhwb3J0IGNvbnN0IGNvbnRleHRNZW51cyA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmNvbnRleHRNZW51cy8udGVzdChzKVxuXG5leHBvcnQgY29uc3QgY29va2llcyA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmNvb2tpZXMvLnRlc3QocylcblxuZXhwb3J0IGNvbnN0IGRlY2xhcmF0aXZlQ29udGVudCA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmRlY2xhcmF0aXZlQ29udGVudC8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGRlY2xhcmF0aXZlTmV0UmVxdWVzdCA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmRlY2xhcmF0aXZlTmV0UmVxdWVzdC8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGRlY2xhcmF0aXZlV2ViUmVxdWVzdCA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmRlY2xhcmF0aXZlV2ViUmVxdWVzdC8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGRlc2t0b3BDYXB0dXJlID0gKHM6IHN0cmluZykgPT5cbiAgL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qZGVza3RvcENhcHR1cmUvLnRlc3QocylcbmV4cG9ydCBjb25zdCBkaXNwbGF5U291cmNlID0gKHM6IHN0cmluZykgPT5cbiAgL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qZGlzcGxheVNvdXJjZS8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGRucyA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmRucy8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGRvY3VtZW50U2NhbiA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmRvY3VtZW50U2Nhbi8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGRvd25sb2FkcyA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmRvd25sb2Fkcy8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbCA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmV4cGVyaW1lbnRhbC8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGZpbGVCcm93c2VySGFuZGxlciA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmZpbGVCcm93c2VySGFuZGxlci8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGZpbGVTeXN0ZW1Qcm92aWRlciA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmZpbGVTeXN0ZW1Qcm92aWRlci8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGZvbnRTZXR0aW5ncyA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmZvbnRTZXR0aW5ncy8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGdjbSA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKmdjbS8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGdlb2xvY2F0aW9uID0gKHM6IHN0cmluZykgPT5cbiAgL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qZ2VvbG9jYXRpb24vLnRlc3QocylcbmV4cG9ydCBjb25zdCBoaXN0b3J5ID0gKHM6IHN0cmluZykgPT5cbiAgL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qaGlzdG9yeS8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gKHM6IHN0cmluZykgPT5cbiAgL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qaWRlbnRpdHkvLnRlc3QocylcbmV4cG9ydCBjb25zdCBpZGxlID0gKHM6IHN0cmluZykgPT5cbiAgL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qaWRsZS8udGVzdChzKVxuZXhwb3J0IGNvbnN0IGlkbHRlc3QgPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSppZGx0ZXN0Ly50ZXN0KHMpXG5leHBvcnQgY29uc3QgbWFuYWdlbWVudCA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKm1hbmFnZW1lbnQvLnRlc3QocylcbmV4cG9ydCBjb25zdCBuYXRpdmVNZXNzYWdpbmcgPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSpuYXRpdmVNZXNzYWdpbmcvLnRlc3QocylcbmV4cG9ydCBjb25zdCBub3RpZmljYXRpb25zID0gKHM6IHN0cmluZykgPT5cbiAgL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qbm90aWZpY2F0aW9ucy8udGVzdChzKVxuZXhwb3J0IGNvbnN0IHBhZ2VDYXB0dXJlID0gKHM6IHN0cmluZykgPT5cbiAgL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qcGFnZUNhcHR1cmUvLnRlc3QocylcbmV4cG9ydCBjb25zdCBwbGF0Zm9ybUtleXMgPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSpwbGF0Zm9ybUtleXMvLnRlc3QocylcbmV4cG9ydCBjb25zdCBwb3dlciA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKnBvd2VyLy50ZXN0KHMpXG5leHBvcnQgY29uc3QgcHJpbnRlclByb3ZpZGVyID0gKHM6IHN0cmluZykgPT5cbiAgL2Nocm9tZXA/W1xcc1xcbl0qXFwuW1xcc1xcbl0qcHJpbnRlclByb3ZpZGVyLy50ZXN0KHMpXG5leHBvcnQgY29uc3QgcHJpdmFjeSA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKnByaXZhY3kvLnRlc3QocylcbmV4cG9ydCBjb25zdCBwcm9jZXNzZXMgPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSpwcm9jZXNzZXMvLnRlc3QocylcbmV4cG9ydCBjb25zdCBwcm94eSA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKnByb3h5Ly50ZXN0KHMpXG5leHBvcnQgY29uc3Qgc2Vzc2lvbnMgPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSpzZXNzaW9ucy8udGVzdChzKVxuZXhwb3J0IGNvbnN0IHNpZ25lZEluRGV2aWNlcyA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKnNpZ25lZEluRGV2aWNlcy8udGVzdChzKVxuZXhwb3J0IGNvbnN0IHN0b3JhZ2UgPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSpzdG9yYWdlLy50ZXN0KHMpXG5leHBvcnQgY29uc3QgdGFiQ2FwdHVyZSA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKnRhYkNhcHR1cmUvLnRlc3Qocylcbi8vIGV4cG9ydCBjb25zdCB0YWJzID0gcyA9PiAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSp0YWJzLy50ZXN0KHMpXG5leHBvcnQgY29uc3QgdG9wU2l0ZXMgPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSp0b3BTaXRlcy8udGVzdChzKVxuZXhwb3J0IGNvbnN0IHR0cyA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKnR0cy8udGVzdChzKVxuZXhwb3J0IGNvbnN0IHR0c0VuZ2luZSA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKnR0c0VuZ2luZS8udGVzdChzKVxuZXhwb3J0IGNvbnN0IHVubGltaXRlZFN0b3JhZ2UgPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSp1bmxpbWl0ZWRTdG9yYWdlLy50ZXN0KHMpXG5leHBvcnQgY29uc3QgdnBuUHJvdmlkZXIgPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSp2cG5Qcm92aWRlci8udGVzdChzKVxuZXhwb3J0IGNvbnN0IHdhbGxwYXBlciA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKndhbGxwYXBlci8udGVzdChzKVxuZXhwb3J0IGNvbnN0IHdlYk5hdmlnYXRpb24gPSAoczogc3RyaW5nKSA9PlxuICAvY2hyb21lcD9bXFxzXFxuXSpcXC5bXFxzXFxuXSp3ZWJOYXZpZ2F0aW9uLy50ZXN0KHMpXG5leHBvcnQgY29uc3Qgd2ViUmVxdWVzdCA9IChzOiBzdHJpbmcpID0+XG4gIC9jaHJvbWVwP1tcXHNcXG5dKlxcLltcXHNcXG5dKndlYlJlcXVlc3QvLnRlc3QocylcbmV4cG9ydCBjb25zdCB3ZWJSZXF1ZXN0QmxvY2tpbmcgPSAoczogc3RyaW5nKSA9PlxuICB3ZWJSZXF1ZXN0KHMpICYmIHMuaW5jbHVkZXMoJ1xcJ2Jsb2NraW5nXFwnJylcblxuLy8gVE9ETzogYWRkIHJlYWRDbGlwYm9hcmRcbi8vIFRPRE86IGFkZCB3cml0ZUNsaXBib2FyZFxuIiwiaW1wb3J0IGdsb2IgZnJvbSAnZ2xvYidcbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoLmdldCdcbmltcG9ydCBkaWZmIGZyb20gJ2xvZGFzaC5kaWZmZXJlbmNlJ1xuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnXG5pbXBvcnQgeyBPdXRwdXRDaHVuayB9IGZyb20gJ3JvbGx1cCdcbmltcG9ydCAqIGFzIHBlcm1pc3Npb25zIGZyb20gJy4vcGVybWlzc2lvbnMnXG5pbXBvcnQge1xuICBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCxcbiAgQ29udGVudFNjcmlwdCxcbn0gZnJvbSAnLi4vLi4vbWFuaWZlc3QnXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4vKiAgICAgICAgICAgICAgREVSSVZFIFBFUk1JU1NJT05TICAgICAgICAgICAgICAqL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuZXhwb3J0IGNvbnN0IGRlcml2ZVBlcm1pc3Npb25zID0gKFxuICBzZXQ6IFNldDxzdHJpbmc+LFxuICB7IGNvZGUgfTogT3V0cHV0Q2h1bmssXG4pID0+XG4gIE9iamVjdC5lbnRyaWVzKHBlcm1pc3Npb25zKVxuICAgIC5maWx0ZXIoKFssIGZuXSkgPT4gZm4oY29kZSkpXG4gICAgLm1hcCgoW2tleV0pID0+IGtleSlcbiAgICAucmVkdWNlKChzLCBwKSA9PiBzLmFkZChwKSwgc2V0KVxuXG4vLyAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuLy8gLyogICAgICAgICAgICAgICAgREVSSVZFIE1BTklGRVNUICAgICAgICAgICAgICAgKi9cbi8vIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBkZXJpdmVNYW5pZmVzdChcbi8vICAgbWFuaWZlc3Q6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LCAvLyBtYW5pZmVzdC5qc29uXG4vLyAgIC4uLnBlcm1pc3Npb25zOiBzdHJpbmdbXSB8IHN0cmluZ1tdW10gLy8gd2lsbCBiZSBjb21iaW5lZCB3aXRoIG1hbmlmZXN0LnBlcm1pc3Npb25zXG4vLyApOiBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCB7XG4vLyAgIHJldHVybiB2YWxpZGF0ZU1hbmlmZXN0KHtcbi8vICAgICAvLyBTTUVMTDogSXMgdGhpcyBuZWNlc3Nhcnk/XG4vLyAgICAgbWFuaWZlc3RfdmVyc2lvbjogMixcbi8vICAgICAuLi5tYW5pZmVzdCxcbi8vICAgICBwZXJtaXNzaW9uczogY29tYmluZVBlcm1zKHBlcm1pc3Npb25zLCBtYW5pZmVzdC5wZXJtaXNzaW9ucyksXG4vLyAgIH0pXG4vLyB9XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vKiAgICAgICAgICAgICAgICAgREVSSVZFIEZJTEVTICAgICAgICAgICAgICAgICAqL1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZUZpbGVzKFxuICBtYW5pZmVzdDogQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QsXG4gIHNyY0Rpcjogc3RyaW5nLFxuKSB7XG4gIGNvbnN0IGZpbGVzID0gZ2V0KFxuICAgIG1hbmlmZXN0LFxuICAgICd3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMnLFxuICAgIFtdIGFzIHN0cmluZ1tdLFxuICApLnJlZHVjZSgociwgeCkgPT4ge1xuICAgIGlmIChnbG9iLmhhc01hZ2ljKHgpKSB7XG4gICAgICBjb25zdCBmaWxlcyA9IGdsb2Iuc3luYyh4LCB7IGN3ZDogc3JjRGlyIH0pXG4gICAgICByZXR1cm4gWy4uLnIsIC4uLmZpbGVzLm1hcCgoZikgPT4gZi5yZXBsYWNlKHNyY0RpciwgJycpKV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFsuLi5yLCB4XVxuICAgIH1cbiAgfSwgW10gYXMgc3RyaW5nW10pXG5cbiAgY29uc3QganMgPSBbXG4gICAgLi4uZmlsZXMuZmlsdGVyKChmKSA9PiAvXFwuW2p0XXN4PyQvLnRlc3QoZikpLFxuICAgIC4uLmdldChtYW5pZmVzdCwgJ2JhY2tncm91bmQuc2NyaXB0cycsIFtdIGFzIHN0cmluZ1tdKSxcbiAgICAuLi5nZXQoXG4gICAgICBtYW5pZmVzdCxcbiAgICAgICdjb250ZW50X3NjcmlwdHMnLFxuICAgICAgW10gYXMgQ29udGVudFNjcmlwdFtdLFxuICAgICkucmVkdWNlKChyLCB7IGpzID0gW10gfSkgPT4gWy4uLnIsIC4uLmpzXSwgW10gYXMgc3RyaW5nW10pLFxuICBdXG5cbiAgY29uc3QgaHRtbCA9IFtcbiAgICAuLi5maWxlcy5maWx0ZXIoKGYpID0+IC9cXC5odG1sPyQvLnRlc3QoZikpLFxuICAgIGdldChtYW5pZmVzdCwgJ2JhY2tncm91bmQucGFnZScpLFxuICAgIGdldChtYW5pZmVzdCwgJ29wdGlvbnNfcGFnZScpLFxuICAgIGdldChtYW5pZmVzdCwgJ2RldnRvb2xzX3BhZ2UnKSxcbiAgICBnZXQobWFuaWZlc3QsICdicm93c2VyX2FjdGlvbi5kZWZhdWx0X3BvcHVwJyksXG4gICAgZ2V0KG1hbmlmZXN0LCAncGFnZV9hY3Rpb24uZGVmYXVsdF9wb3B1cCcpLFxuICAgIC4uLk9iamVjdC52YWx1ZXMoZ2V0KG1hbmlmZXN0LCAnY2hyb21lX3VybF9vdmVycmlkZXMnLCB7fSkpLFxuICBdXG5cbiAgY29uc3QgY3NzID0gW1xuICAgIC4uLmZpbGVzLmZpbHRlcigoZikgPT4gZi5lbmRzV2l0aCgnLmNzcycpKSxcbiAgICAuLi5nZXQoXG4gICAgICBtYW5pZmVzdCxcbiAgICAgICdjb250ZW50X3NjcmlwdHMnLFxuICAgICAgW10gYXMgQ29udGVudFNjcmlwdFtdLFxuICAgICkucmVkdWNlKFxuICAgICAgKHIsIHsgY3NzID0gW10gfSkgPT4gWy4uLnIsIC4uLmNzc10sXG4gICAgICBbXSBhcyBzdHJpbmdbXSxcbiAgICApLFxuICBdXG5cbiAgLy8gVE9ETzogdGhpcyBjYW4gYmUgYSBzdHJpbmcgb3Igb2JqZWN0XG4gIGNvbnN0IGFjdGlvbkljb25TZXQgPSBbXG4gICAgJ2Jyb3dzZXJfYWN0aW9uLmRlZmF1bHRfaWNvbicsXG4gICAgJ3BhZ2VfYWN0aW9uLmRlZmF1bHRfaWNvbicsXG4gIF0ucmVkdWNlKChzZXQsIHF1ZXJ5KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0OiBzdHJpbmcgfCB7IFtzaXplOiBzdHJpbmddOiBzdHJpbmcgfSA9IGdldChcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcXVlcnksXG4gICAgICB7fSxcbiAgICApXG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNldC5hZGQocmVzdWx0KVxuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QudmFsdWVzKHJlc3VsdCkuZm9yRWFjaCgoeCkgPT4gc2V0LmFkZCh4KSlcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0XG4gIH0sIG5ldyBTZXQ8c3RyaW5nPigpKVxuXG4gIGNvbnN0IGltZyA9IFtcbiAgICAuLi5hY3Rpb25JY29uU2V0LFxuICAgIC4uLmZpbGVzLmZpbHRlcigoZikgPT5cbiAgICAgIC9cXC4oanBlP2d8cG5nfHN2Z3x0aWZmP3xnaWZ8d2VicHxibXB8aWNvKSQvaS50ZXN0KGYpLFxuICAgICksXG4gICAgLi4uT2JqZWN0LnZhbHVlcyhnZXQobWFuaWZlc3QsICdpY29ucycsIHt9KSksXG4gIF1cblxuICAvLyBGaWxlcyBsaWtlIGZvbnRzLCB0aGluZ3MgdGhhdCBhcmUgbm90IGV4cGVjdGVkXG4gIGNvbnN0IG90aGVycyA9IGRpZmYoZmlsZXMsIGNzcywganMsIGh0bWwsIGltZylcblxuICByZXR1cm4ge1xuICAgIGNzczogdmFsaWRhdGUoY3NzKSxcbiAgICBqczogdmFsaWRhdGUoanMpLFxuICAgIGh0bWw6IHZhbGlkYXRlKGh0bWwpLFxuICAgIGltZzogdmFsaWRhdGUoaW1nKSxcbiAgICBvdGhlcnM6IHZhbGlkYXRlKG90aGVycyksXG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShhcnk6IGFueVtdKSB7XG4gICAgcmV0dXJuIFsuLi5uZXcgU2V0KGFyeS5maWx0ZXIoaXNTdHJpbmcpKV0ubWFwKCh4KSA9PlxuICAgICAgam9pbihzcmNEaXIsIHgpLFxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RyaW5nKHg6IGFueSk6IHggaXMgc3RyaW5nIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdzdHJpbmcnXG4gIH1cbn1cbiIsImltcG9ydCBBanYgZnJvbSAnYWp2J1xuaW1wb3J0IHsgQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QgfSBmcm9tICcuLi8uLi9tYW5pZmVzdCdcbmltcG9ydCBqc29uU2NoZW1hIGZyb20gJy4vanNvbi1zY2hlbWEtZHJhZnQtMDQuanNvbidcbmltcG9ydCBtYW5pZmVzdFNjaGVtYSBmcm9tICcuL3NjaGVtYS13ZWItZXh0LW1hbmlmZXN0LXYyLmpzb24nXG5cbmV4cG9ydCB0eXBlIFZhbGlkYXRpb25FcnJvcnNBcnJheSA9XG4gIHwgQWp2LkVycm9yT2JqZWN0W11cbiAgfCBudWxsXG4gIHwgdW5kZWZpbmVkXG5leHBvcnQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihtc2c6IHN0cmluZywgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JzQXJyYXkpIHtcbiAgICBzdXBlcihtc2cpXG4gICAgdGhpcy5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcidcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yc1xuICB9XG4gIGVycm9yczogVmFsaWRhdGlvbkVycm9yc0FycmF5XG59XG5cbi8vIGNvbnN0IGpzb25TY2hlbWEgPSByZWFkSlNPTlN5bmMoXG4vLyAgIHJlc29sdmUoX19kaXJuYW1lLCAnanNvbi1zY2hlbWEtZHJhZnQtMDQuanNvbicpLFxuLy8gKVxuXG4vLyBjb25zdCBtYW5pZmVzdFNjaGVtYSA9IHJlYWRKU09OU3luYyhcbi8vICAgcmVzb2x2ZShfX2Rpcm5hbWUsICdzY2hlbWEtd2ViLWV4dC1tYW5pZmVzdC12Mi5qc29uJyksXG4vLyApXG5cbmV4cG9ydCBjb25zdCBhanYgPSBuZXcgQWp2KHtcbiAgdmVyYm9zZTogdHJ1ZSxcbiAgc2NoZW1hSWQ6ICdhdXRvJyxcbiAgc2NoZW1hczoge1xuICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSMnOiBqc29uU2NoZW1hLFxuICB9LFxuICBzdHJpY3REZWZhdWx0czogdHJ1ZSxcbn0pXG5cbi8vIGFqdi5hZGRNZXRhU2NoZW1hKGpzb25TY2hlbWEpXG5cbmNvbnN0IHZhbGlkYXRvciA9IGFqdi5jb21waWxlKG1hbmlmZXN0U2NoZW1hKVxuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVNYW5pZmVzdCA9IChcbiAgbWFuaWZlc3Q6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LFxuKSA9PiB7XG4gIGlmICh2YWxpZGF0b3IobWFuaWZlc3QpKSB7XG4gICAgcmV0dXJuIG1hbmlmZXN0XG4gIH1cblxuICBjb25zdCB7IGVycm9ycyB9ID0gdmFsaWRhdG9yXG4gIGNvbnN0IG1zZyA9ICdUaGVyZSB3ZXJlIHByb2JsZW1zIHdpdGggdGhlIGV4dGVuc2lvbiBtYW5pZmVzdC4nXG5cbiAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihtc2csIGVycm9ycylcbn1cbiIsImltcG9ydCB7IGNvZGUgYXMgY29udGVudFNjcmlwdFdyYXBwZXIgfSBmcm9tICdjb2RlIC4vYnJvd3Nlci9jb250ZW50U2NyaXB0V3JhcHBlci50cydcbmltcG9ydCB7IGNvc21pY29uZmlnU3luYyB9IGZyb20gJ2Nvc21pY29uZmlnJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJ1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnbWVtJ1xuaW1wb3J0IHBhdGgsIHsgYmFzZW5hbWUsIHJlbGF0aXZlIH0gZnJvbSAncGF0aCdcbmltcG9ydCB7IEVtaXR0ZWRBc3NldCwgT3V0cHV0Q2h1bmssIFBsdWdpbkhvb2tzIH0gZnJvbSAncm9sbHVwJ1xuaW1wb3J0IHNsYXNoIGZyb20gJ3NsYXNoJ1xuaW1wb3J0IHsgaXNDaHVuaywgaXNKc29uRmlsZVBhdGggfSBmcm9tICcuLi9oZWxwZXJzJ1xuaW1wb3J0IHsgQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QgfSBmcm9tICcuLi9tYW5pZmVzdCdcbmltcG9ydCB7IGNsb25lT2JqZWN0IH0gZnJvbSAnLi9jbG9uZU9iamVjdCdcbmltcG9ydCB7XG4gIER5bmFtaWNJbXBvcnRXcmFwcGVyT3B0aW9ucyxcbiAgcHJlcEltcG9ydFdyYXBwZXJTY3JpcHQsXG59IGZyb20gJy4vZHluYW1pY0ltcG9ydFdyYXBwZXInXG5pbXBvcnQgeyBjb21iaW5lUGVybXMgfSBmcm9tICcuL21hbmlmZXN0LXBhcnNlci9jb21iaW5lJ1xuaW1wb3J0IHtcbiAgZGVyaXZlRmlsZXMsXG4gIGRlcml2ZVBlcm1pc3Npb25zLFxufSBmcm9tICcuL21hbmlmZXN0LXBhcnNlci9pbmRleCdcbmltcG9ydCB7XG4gIHZhbGlkYXRlTWFuaWZlc3QsXG4gIFZhbGlkYXRpb25FcnJvcnNBcnJheSxcbn0gZnJvbSAnLi9tYW5pZmVzdC1wYXJzZXIvdmFsaWRhdGUnXG5pbXBvcnQgeyByZWR1Y2VUb1JlY29yZCB9IGZyb20gJy4vcmVkdWNlVG9SZWNvcmQnXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWR1cGU8VD4oeDogVFtdKTogVFtdIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KHgpXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hbmlmZXN0SW5wdXRQbHVnaW5DYWNoZSB7XG4gIGFzc2V0czogc3RyaW5nW11cbiAgaW5wdXQ6IHN0cmluZ1tdXG4gIGlucHV0QXJ5OiBzdHJpbmdbXVxuICBpbnB1dE9iajogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBwZXJtc0hhc2g6IHN0cmluZ1xuICBzcmNEaXI6IHN0cmluZyB8IG51bGxcbiAgLyoqIGZvciBtZW1vaXplZCBmcy5yZWFkRmlsZSAqL1xuICByZWFkRmlsZTogTWFwPHN0cmluZywgYW55PlxuICBtYW5pZmVzdD86IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0XG4gIGFzc2V0Q2hhbmdlZDogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBNYW5pZmVzdElucHV0UGx1Z2luID0gUGljazxcbiAgUGx1Z2luSG9va3MsXG4gICdvcHRpb25zJyB8ICdidWlsZFN0YXJ0JyB8ICd3YXRjaENoYW5nZScgfCAnZ2VuZXJhdGVCdW5kbGUnXG4+ICYge1xuICBuYW1lOiBzdHJpbmdcbiAgc3JjRGlyOiBzdHJpbmcgfCBudWxsXG59XG5cbmV4cG9ydCBjb25zdCBleHBsb3JlciA9IGNvc21pY29uZmlnU3luYygnbWFuaWZlc3QnLCB7XG4gIGNhY2hlOiBmYWxzZSxcbn0pXG5cbmNvbnN0IG5hbWUgPSAnbWFuaWZlc3QtaW5wdXQnXG5cbmNvbnN0IG5wbVBrZ0RldGFpbHMgPVxuICBwcm9jZXNzLmVudi5ucG1fcGFja2FnZV9uYW1lICYmXG4gIHByb2Nlc3MuZW52Lm5wbV9wYWNrYWdlX3ZlcnNpb24gJiZcbiAgcHJvY2Vzcy5lbnYubnBtX3BhY2thZ2VfZGVzY3JpcHRpb25cbiAgICA/IHtcbiAgICAgICAgbmFtZTogcHJvY2Vzcy5lbnYubnBtX3BhY2thZ2VfbmFtZSxcbiAgICAgICAgdmVyc2lvbjogcHJvY2Vzcy5lbnYubnBtX3BhY2thZ2VfdmVyc2lvbixcbiAgICAgICAgZGVzY3JpcHRpb246IHByb2Nlc3MuZW52Lm5wbV9wYWNrYWdlX2Rlc2NyaXB0aW9uLFxuICAgICAgfVxuICAgIDoge1xuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgdmVyc2lvbjogJycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgIH1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbi8qICAgICAgICAgICAgICAgIE1BTklGRVNULUlOUFVUICAgICAgICAgICAgICAgICovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWFuaWZlc3RJbnB1dChcbiAge1xuICAgIGR5bmFtaWNJbXBvcnRXcmFwcGVyID0ge30sXG4gICAgcGtnID0gbnBtUGtnRGV0YWlscyxcbiAgICBwdWJsaWNLZXksXG4gICAgdmVyYm9zZSA9IHRydWUsXG4gICAgY2FjaGUgPSB7XG4gICAgICBhc3NldENoYW5nZWQ6IGZhbHNlLFxuICAgICAgYXNzZXRzOiBbXSxcbiAgICAgIGlucHV0OiBbXSxcbiAgICAgIGlucHV0QXJ5OiBbXSxcbiAgICAgIGlucHV0T2JqOiB7fSxcbiAgICAgIHBlcm1zSGFzaDogJycsXG4gICAgICByZWFkRmlsZTogbmV3IE1hcDxzdHJpbmcsIGFueT4oKSxcbiAgICAgIHNyY0RpcjogbnVsbCxcbiAgICB9IGFzIE1hbmlmZXN0SW5wdXRQbHVnaW5DYWNoZSxcbiAgfSA9IHt9IGFzIHtcbiAgICBkeW5hbWljSW1wb3J0V3JhcHBlcj86IER5bmFtaWNJbXBvcnRXcmFwcGVyT3B0aW9ucyB8IGZhbHNlXG4gICAgcGtnPzoge1xuICAgICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICAgICAgbmFtZTogc3RyaW5nXG4gICAgICB2ZXJzaW9uOiBzdHJpbmdcbiAgICB9XG4gICAgcHVibGljS2V5Pzogc3RyaW5nXG4gICAgdmVyYm9zZT86IGJvb2xlYW5cbiAgICBjYWNoZT86IE1hbmlmZXN0SW5wdXRQbHVnaW5DYWNoZVxuICB9LFxuKTogTWFuaWZlc3RJbnB1dFBsdWdpbiB7XG4gIGNvbnN0IHJlYWRBc3NldEFzQnVmZmVyID0gbWVtb2l6ZShcbiAgICAoZmlsZXBhdGg6IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlKGZpbGVwYXRoKVxuICAgIH0sXG4gICAge1xuICAgICAgY2FjaGU6IGNhY2hlLnJlYWRGaWxlLFxuICAgIH0sXG4gIClcblxuICAvKiAtLS0tLS0tLS0tLSBIT09LUyBDTE9TVVJFUyBTVEFSVCAtLS0tLS0tLS0tLSAqL1xuXG4gIGxldCBtYW5pZmVzdFBhdGg6IHN0cmluZ1xuXG4gIGNvbnN0IG1hbmlmZXN0TmFtZSA9ICdtYW5pZmVzdC5qc29uJ1xuXG4gIC8qIC0tLS0tLS0tLS0tLSBIT09LUyBDTE9TVVJFUyBFTkQgLS0tLS0tLS0tLS0tICovXG5cbiAgLyogLSBTRVRVUCBEWU5BTUlDIElNUE9SVCBMT0FERVIgU0NSSVBUIFNUQVJUIC0gKi9cblxuICBsZXQgd3JhcHBlclNjcmlwdCA9ICcnXG4gIGlmIChkeW5hbWljSW1wb3J0V3JhcHBlciAhPT0gZmFsc2UpIHtcbiAgICB3cmFwcGVyU2NyaXB0ID0gcHJlcEltcG9ydFdyYXBwZXJTY3JpcHQoZHluYW1pY0ltcG9ydFdyYXBwZXIpXG4gIH1cblxuICAvKiAtLSBTRVRVUCBEWU5BTUlDIElNUE9SVCBMT0FERVIgU0NSSVBUIEVORCAtLSAqL1xuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLSBwbHVnaW4gb2JqZWN0IC0tLS0tLS0tLS0tLS0tICovXG4gIHJldHVybiB7XG4gICAgbmFtZSxcblxuICAgIGdldCBzcmNEaXIoKSB7XG4gICAgICByZXR1cm4gY2FjaGUuc3JjRGlyXG4gICAgfSxcblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gICAgLyogICAgICAgICAgICAgICAgIE9QVElPTlMgSE9PSyAgICAgICAgICAgICAgICAgKi9cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAvLyBEbyBub3QgcmVsb2FkIG1hbmlmZXN0IHdpdGhvdXQgY2hhbmdlc1xuICAgICAgaWYgKCFjYWNoZS5tYW5pZmVzdCkge1xuICAgICAgICAvKiAtLS0tLS0tLS0tLSBMT0FEIEFORCBQUk9DRVNTIE1BTklGRVNUIC0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgbGV0IGlucHV0TWFuaWZlc3RQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnB1dCkpIHtcbiAgICAgICAgICBjb25zdCBtYW5pZmVzdEluZGV4ID0gb3B0aW9ucy5pbnB1dC5maW5kSW5kZXgoXG4gICAgICAgICAgICBpc0pzb25GaWxlUGF0aCxcbiAgICAgICAgICApXG4gICAgICAgICAgaW5wdXRNYW5pZmVzdFBhdGggPSBvcHRpb25zLmlucHV0W21hbmlmZXN0SW5kZXhdXG4gICAgICAgICAgY2FjaGUuaW5wdXRBcnkgPSBbXG4gICAgICAgICAgICAuLi5vcHRpb25zLmlucHV0LnNsaWNlKDAsIG1hbmlmZXN0SW5kZXgpLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5pbnB1dC5zbGljZShtYW5pZmVzdEluZGV4ICsgMSksXG4gICAgICAgICAgXVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlucHV0TWFuaWZlc3RQYXRoID0gb3B0aW9ucy5pbnB1dC5tYW5pZmVzdFxuICAgICAgICAgIGNhY2hlLmlucHV0T2JqID0gY2xvbmVPYmplY3Qob3B0aW9ucy5pbnB1dClcbiAgICAgICAgICBkZWxldGUgY2FjaGUuaW5wdXRPYmpbJ21hbmlmZXN0J11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dE1hbmlmZXN0UGF0aCA9IG9wdGlvbnMuaW5wdXRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNKc29uRmlsZVBhdGgoaW5wdXRNYW5pZmVzdFBhdGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdSb2xsdXBPcHRpb25zLmlucHV0IG11c3QgYmUgYSBzaW5nbGUgQ2hyb21lIGV4dGVuc2lvbiBtYW5pZmVzdC4nLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IGV4cGxvcmVyLmxvYWQoXG4gICAgICAgICAgaW5wdXRNYW5pZmVzdFBhdGgsXG4gICAgICAgICkgYXMge1xuICAgICAgICAgIGZpbGVwYXRoOiBzdHJpbmdcbiAgICAgICAgICBjb25maWc6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0XG4gICAgICAgICAgaXNFbXB0eT86IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWdSZXN1bHQuaXNFbXB0eSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb25zLmlucHV0fSBpcyBhbiBlbXB0eSBmaWxlLmApXG4gICAgICAgIH1cblxuICAgICAgICBtYW5pZmVzdFBhdGggPSBjb25maWdSZXN1bHQuZmlsZXBhdGhcbiAgICAgICAgY2FjaGUubWFuaWZlc3QgPSBjb25maWdSZXN1bHQuY29uZmlnXG5cbiAgICAgICAgY2FjaGUuc3JjRGlyID0gcGF0aC5kaXJuYW1lKG1hbmlmZXN0UGF0aClcblxuICAgICAgICAvLyBEZXJpdmUgZW50cnkgcGF0aHMgZnJvbSBtYW5pZmVzdFxuICAgICAgICBjb25zdCB7IGpzLCBodG1sLCBjc3MsIGltZywgb3RoZXJzIH0gPSBkZXJpdmVGaWxlcyhcbiAgICAgICAgICBjYWNoZS5tYW5pZmVzdCxcbiAgICAgICAgICBjYWNoZS5zcmNEaXIsXG4gICAgICAgIClcblxuICAgICAgICAvLyBDYWNoZSBkZXJpdmVkIGlucHV0c1xuICAgICAgICBjYWNoZS5pbnB1dCA9IFsuLi5jYWNoZS5pbnB1dEFyeSwgLi4uanMsIC4uLmh0bWxdXG4gICAgICAgIGNhY2hlLmFzc2V0cyA9IFtcbiAgICAgICAgICAvLyBEZWR1cGUgYXNzZXRzXG4gICAgICAgICAgLi4ubmV3IFNldChbLi4uY3NzLCAuLi5pbWcsIC4uLm90aGVyc10pLFxuICAgICAgICBdXG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tIEVORCBMT0FEIE1BTklGRVNUIC0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FjaGUuaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIG1hbmlmZXN0IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc2NyaXB0IG9yIEhUTUwgZmlsZS4nLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIHVzaW5nIHRoaXMuZW1pdEZpbGUgaW4gYnVpbGRTdGFydCBpbnN0ZWFkXG4gICAgICAvLyAgLSB0aGUgaW5wdXQgcmVjb3JkIGlzIHVudXN1YWwsIGJ1dCB3b3VsZCB0aGlzIGJlIG1vcmUgdW51c3VhbD9cbiAgICAgIC8vICAtIHdvdWxkIG5lZWQgdG8gcHV0IHNvbWV0aGluZyBoZXJlLCBjYW4ndCByZXR1cm4gYW4gZW1wdHkgaW5wdXRcbiAgICAgIC8vICAgIC0gbWF5YmUgYSBkdW1teSBmaWxlIHRvIHJlbW92ZSBpbiBnZW5lcmF0ZUJ1bmRsZT9cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGlucHV0OiBjYWNoZS5pbnB1dC5yZWR1Y2UoXG4gICAgICAgICAgcmVkdWNlVG9SZWNvcmQoY2FjaGUuc3JjRGlyKSxcbiAgICAgICAgICBjYWNoZS5pbnB1dE9iaixcbiAgICAgICAgKSxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgICAvKiAgICAgICAgICAgICAgSEFORExFIFdBVENIIEZJTEVTICAgICAgICAgICAgICAqL1xuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBhc3luYyBidWlsZFN0YXJ0KCkge1xuICAgICAgdGhpcy5hZGRXYXRjaEZpbGUobWFuaWZlc3RQYXRoKVxuXG4gICAgICBjYWNoZS5hc3NldHMuZm9yRWFjaCgoc3JjUGF0aCkgPT4ge1xuICAgICAgICB0aGlzLmFkZFdhdGNoRmlsZShzcmNQYXRoKVxuICAgICAgfSlcblxuICAgICAgY29uc3QgYXNzZXRzOiBFbWl0dGVkQXNzZXRbXSA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBjYWNoZS5hc3NldHMubWFwKGFzeW5jIChzcmNQYXRoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gYXdhaXQgcmVhZEFzc2V0QXNCdWZmZXIoc3JjUGF0aClcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnYXNzZXQnIGFzIGNvbnN0LFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgZmlsZU5hbWU6IHBhdGgucmVsYXRpdmUoY2FjaGUuc3JjRGlyISwgc3JjUGF0aCksXG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgIClcblxuICAgICAgYXNzZXRzLmZvckVhY2goKGFzc2V0KSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdEZpbGUoYXNzZXQpXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICB3YXRjaENoYW5nZShpZCkge1xuICAgICAgaWYgKGlkLmVuZHNXaXRoKG1hbmlmZXN0TmFtZSkpIHtcbiAgICAgICAgLy8gRHVtcCBjYWNoZS5tYW5pZmVzdCBpZiBtYW5pZmVzdCBjaGFuZ2VzXG4gICAgICAgIGRlbGV0ZSBjYWNoZS5tYW5pZmVzdFxuICAgICAgICBjYWNoZS5hc3NldENoYW5nZWQgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yY2UgbmV3IHJlYWQgb2YgY2hhbmdlZCBhc3NldFxuICAgICAgICBjYWNoZS5hc3NldENoYW5nZWQgPSBjYWNoZS5yZWFkRmlsZS5kZWxldGUoaWQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gICAgLyogICAgICAgICAgICAgICAgR0VORVJBVEVCVU5ETEUgICAgICAgICAgICAgICAgKi9cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgZ2VuZXJhdGVCdW5kbGUob3B0aW9ucywgYnVuZGxlKSB7XG4gICAgICAvKiAtLS0tLS0tLS0tIERFUklWRSBQRVJNSVNJT05TIFNUQVJUIC0tLS0tLS0tLSAqL1xuXG4gICAgICAvLyBHZXQgbW9kdWxlIGlkcyBmb3IgYWxsIGNodW5rc1xuICAgICAgbGV0IHBlcm1pc3Npb25zOiBzdHJpbmdbXVxuICAgICAgaWYgKGNhY2hlLmFzc2V0Q2hhbmdlZCAmJiBjYWNoZS5wZXJtc0hhc2gpIHtcbiAgICAgICAgLy8gUGVybWlzc2lvbnMgZGlkIG5vdCBjaGFuZ2VcbiAgICAgICAgcGVybWlzc2lvbnMgPSBKU09OLnBhcnNlKGNhY2hlLnBlcm1zSGFzaCkgYXMgc3RyaW5nW11cblxuICAgICAgICBjYWNoZS5hc3NldENoYW5nZWQgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gT2JqZWN0LnZhbHVlcyhidW5kbGUpLmZpbHRlcihpc0NodW5rKVxuXG4gICAgICAgIC8vIFBlcm1pc3Npb25zIG1heSBoYXZlIGNoYW5nZWRcbiAgICAgICAgcGVybWlzc2lvbnMgPSBBcnJheS5mcm9tKFxuICAgICAgICAgIGNodW5rcy5yZWR1Y2UoZGVyaXZlUGVybWlzc2lvbnMsIG5ldyBTZXQ8c3RyaW5nPigpKSxcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IHBlcm1zSGFzaCA9IEpTT04uc3RyaW5naWZ5KHBlcm1pc3Npb25zKVxuXG4gICAgICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgICAgaWYgKCFjYWNoZS5wZXJtc0hhc2gpIHtcbiAgICAgICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICAgICAgYERldGVjdGVkIHBlcm1pc3Npb25zOiAke3Blcm1pc3Npb25zLnRvU3RyaW5nKCl9YCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2UgaWYgKHBlcm1zSGFzaCAhPT0gY2FjaGUucGVybXNIYXNoKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICAgIGBEZXRlY3RlZCBuZXcgcGVybWlzc2lvbnM6ICR7cGVybWlzc2lvbnMudG9TdHJpbmcoKX1gLFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlLnBlcm1zSGFzaCA9IHBlcm1zSGFzaFxuICAgICAgfVxuXG4gICAgICAvKiAtLS0tLS0tLS0tIERFUklWRSBQRVJNSVNTSU9OUyBFTkQgLS0tLS0tLS0tLSAqL1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBDbG9uZSBjYWNoZS5tYW5pZmVzdFxuICAgICAgICBpZiAoIWNhY2hlLm1hbmlmZXN0KVxuICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcm9ncmFtbWluZyBlcnJvciwgc28gaXQgc2hvdWxkIHRocm93XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBjYWNoZS5tYW5pZmVzdCBpcyAke3R5cGVvZiBjYWNoZS5tYW5pZmVzdH1gLFxuICAgICAgICAgIClcblxuICAgICAgICBjb25zdCBjbG9uZWRNYW5pZmVzdCA9IGNsb25lT2JqZWN0KGNhY2hlLm1hbmlmZXN0KVxuXG4gICAgICAgIGNvbnN0IG1hbmlmZXN0Qm9keSA9IHZhbGlkYXRlTWFuaWZlc3Qoe1xuICAgICAgICAgIG1hbmlmZXN0X3ZlcnNpb246IDIsXG4gICAgICAgICAgbmFtZTogcGtnLm5hbWUsXG4gICAgICAgICAgdmVyc2lvbjogcGtnLnZlcnNpb24sXG4gICAgICAgICAgZGVzY3JpcHRpb246IHBrZy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAuLi5jbG9uZWRNYW5pZmVzdCxcbiAgICAgICAgICBwZXJtaXNzaW9uczogY29tYmluZVBlcm1zKFxuICAgICAgICAgICAgcGVybWlzc2lvbnMsXG4gICAgICAgICAgICBjbG9uZWRNYW5pZmVzdC5wZXJtaXNzaW9ucyB8fCBbXSxcbiAgICAgICAgICApLFxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjb250ZW50X3NjcmlwdHM6IGN0cyA9IFtdLFxuICAgICAgICAgIHdlYl9hY2Nlc3NpYmxlX3Jlc291cmNlczogd2FyID0gW10sXG4gICAgICAgICAgYmFja2dyb3VuZDogeyBzY3JpcHRzOiBiZ3MgPSBbXSB9ID0ge30sXG4gICAgICAgIH0gPSBtYW5pZmVzdEJvZHlcblxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tIFNFVFVQIENPTlRFTlQgU0NSSVBUUyAtLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgY29uc3QgY29udGVudFNjcmlwdHMgPSBjdHMucmVkdWNlKFxuICAgICAgICAgIChyLCB7IGpzID0gW10gfSkgPT4gWy4uLnIsIC4uLmpzXSxcbiAgICAgICAgICBbXSBhcyBzdHJpbmdbXSxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChjb250ZW50U2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBtZW1vaXplZEVtaXR0ZXIgPSBtZW1vaXplKFxuICAgICAgICAgICAgKHNjcmlwdFBhdGg6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBjb250ZW50U2NyaXB0V3JhcHBlci5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICclUEFUSCUnLFxuICAgICAgICAgICAgICAgIC8vIEZpeCBwYXRoIHNsYXNoZXMgdG8gc3VwcG9ydCBXaW5kb3dzXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICBzbGFzaChyZWxhdGl2ZSgnYXNzZXRzJywgc2NyaXB0UGF0aCkpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICBjb25zdCBhc3NldElkID0gdGhpcy5lbWl0RmlsZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Fzc2V0JyxcbiAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgbmFtZTogYmFzZW5hbWUoc2NyaXB0UGF0aCksXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZU5hbWUoYXNzZXRJZClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLy8gU2V0dXAgY29udGVudCBzY3JpcHQgaW1wb3J0IHdyYXBwZXJcbiAgICAgICAgICBtYW5pZmVzdEJvZHkuY29udGVudF9zY3JpcHRzID0gY3RzLm1hcChcbiAgICAgICAgICAgICh7IGpzLCAuLi5yZXN0IH0pID0+XG4gICAgICAgICAgICAgIHR5cGVvZiBqcyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHJlc3RcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAganM6IGpzXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcCgocCkgPT4gcC5yZXBsYWNlKC9cXC50cyQvLCAnLmpzJykpXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChtZW1vaXplZEVtaXR0ZXIpLFxuICAgICAgICAgICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvLyBtYWtlIGFsbCBpbXBvcnRzICYgZHluYW1pYyBpbXBvcnRzIHdlYl9hY2NfcmVzXG4gICAgICAgICAgY29uc3QgaW1wb3J0cyA9IE9iamVjdC52YWx1ZXMoYnVuZGxlKVxuICAgICAgICAgICAgLmZpbHRlcigoeCk6IHggaXMgT3V0cHV0Q2h1bmsgPT4geC50eXBlID09PSAnY2h1bmsnKVxuICAgICAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAgICAgKHIsIHsgaXNFbnRyeSwgZmlsZU5hbWUgfSkgPT5cbiAgICAgICAgICAgICAgICAvLyBHZXQgaW1wb3J0ZWQgZmlsZW5hbWVzXG4gICAgICAgICAgICAgICAgIWlzRW50cnkgPyBbLi4uciwgZmlsZU5hbWVdIDogcixcbiAgICAgICAgICAgICAgW10gYXMgc3RyaW5nW10sXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAvLyBTTUVMTDogd2ViIGFjY2Vzc2libGUgcmVzb3VyY2VzIGNhbiBiZSB1c2VkIGZvciBmaW5nZXJwcmludGluZyBleHRlbnNpb25zXG4gICAgICAgICAgbWFuaWZlc3RCb2R5LndlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcyA9IGRlZHVwZShbXG4gICAgICAgICAgICAuLi53YXIsXG4gICAgICAgICAgICAvLyBGRUFUVVJFOiBmaWx0ZXIgb3V0IGltcG9ydHMgZm9yIGJhY2tncm91bmQ/XG4gICAgICAgICAgICAuLi5pbXBvcnRzLFxuICAgICAgICAgICAgLy8gTmVlZCB0byBiZSB3ZWIgYWNjZXNzaWJsZSBiL2Mgb2YgaW1wb3J0XG4gICAgICAgICAgICAuLi5jb250ZW50U2NyaXB0cyxcbiAgICAgICAgICBdKVxuICAgICAgICB9XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0gRU5EIFNFVFVQIENPTlRFTlQgU0NSSVBUUyAtLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLSBTRVRVUCBCQUNLR1JPVU5EIFNDUklQVFMgLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICAvLyBFbWl0IGJhY2tncm91bmQgc2NyaXB0IHdyYXBwZXJzXG4gICAgICAgIGlmIChiZ3MubGVuZ3RoICYmIHdyYXBwZXJTY3JpcHQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gYmFja2dyb3VuZCBleGlzdHMgYmVjYXVzZSBiZ3MgaGFzIHNjcmlwdHNcbiAgICAgICAgICBtYW5pZmVzdEJvZHkuYmFja2dyb3VuZCEuc2NyaXB0cyA9IGJnc1xuICAgICAgICAgICAgLy8gU01FTEw6IGlzIHRoaXMgcmVwbGFjZSBuZWNlc3Nhcnk/IGFyZSB3ZSBkb2luZyBzb21ld2hlcmUgZWxzZT9cbiAgICAgICAgICAgIC5tYXAoKHApID0+IHAucmVwbGFjZSgvXFwudHMkLywgJy5qcycpKVxuICAgICAgICAgICAgLm1hcCgoc2NyaXB0UGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgIC8vIExvYWRlciBzY3JpcHQgZXhpc3RzIGJlY2F1c2Ugb2YgdHlwZSBndWFyZCBhYm92ZVxuICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPVxuICAgICAgICAgICAgICAgIC8vIFBhdGggdG8gbW9kdWxlIGJlaW5nIGxvYWRlZFxuICAgICAgICAgICAgICAgIHdyYXBwZXJTY3JpcHQucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICclUEFUSCUnLFxuICAgICAgICAgICAgICAgICAgLy8gRml4IHBhdGggc2xhc2hlcyB0byBzdXBwb3J0IFdpbmRvd3NcbiAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICBzbGFzaChyZWxhdGl2ZSgnYXNzZXRzJywgc2NyaXB0UGF0aCkpLFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgY29uc3QgYXNzZXRJZCA9IHRoaXMuZW1pdEZpbGUoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhc3NldCcsXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIG5hbWU6IGJhc2VuYW1lKHNjcmlwdFBhdGgpLFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpbGVOYW1lKGFzc2V0SWQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLyogLS0tLS0tLS0tLSBFTkQgU0VUVVAgQkFDS0dST1VORCBTQ1JJUFRTIC0tLS0tLS0tLSAqL1xuXG4gICAgICAgIC8qIC0tLS0tLS0tLSBTVEFCTEUgRVhURU5TSU9OIElEIEJFR0lOIC0tLS0tLS0tICovXG5cbiAgICAgICAgaWYgKHB1YmxpY0tleSkge1xuICAgICAgICAgIG1hbmlmZXN0Qm9keS5rZXkgPSBwdWJsaWNLZXlcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIC0tLS0tLS0tLS0gU1RBQkxFIEVYVEVOU0lPTiBJRCBFTkQgLS0tLS0tLS0tICovXG5cbiAgICAgICAgLyogLS0tLS0tLS0tLS0gT1VUUFVUIE1BTklGRVNULkpTT04gQkVHSU4gLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgIGNvbnN0IG1hbmlmZXN0SnNvbiA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIG1hbmlmZXN0Qm9keSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIDIsXG4gICAgICAgIClcbiAgICAgICAgICAvLyBTTUVMTDogaXMgdGhpcyBuZWNlc3Nhcnk/XG4gICAgICAgICAgLnJlcGxhY2UoL1xcLltqdF1zeD9cIi9nLCAnLmpzXCInKVxuXG4gICAgICAgIC8vIEVtaXQgbWFuaWZlc3QuanNvblxuICAgICAgICB0aGlzLmVtaXRGaWxlKHtcbiAgICAgICAgICB0eXBlOiAnYXNzZXQnLFxuICAgICAgICAgIGZpbGVOYW1lOiBtYW5pZmVzdE5hbWUsXG4gICAgICAgICAgc291cmNlOiBtYW5pZmVzdEpzb24sXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBDYXRjaCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0aGUgdmFsaWRhdGVkIHJlc3VsdCBpbiBzY29wZVxuXG4gICAgICAgIGlmIChlcnJvci5uYW1lICE9PSAnVmFsaWRhdGlvbkVycm9yJykgdGhyb3cgZXJyb3JcbiAgICAgICAgY29uc3QgZXJyb3JzID0gZXJyb3IuZXJyb3JzIGFzIFZhbGlkYXRpb25FcnJvcnNBcnJheVxuICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgZXJyb3JzLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICAgICAgLy8gRklYTUU6IG1ha2UgYSBiZXR0ZXIgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXRsYXNzaWFuL2JldHRlci1hanYtZXJyb3JzXG4gICAgICAgICAgICB0aGlzLndhcm4oSlNPTi5zdHJpbmdpZnkoZXJyLCB1bmRlZmluZWQsIDIpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJvcihlcnJvci5tZXNzYWdlKVxuICAgICAgfVxuXG4gICAgICAvKiAtLS0tLS0tLS0tLS0gT1VUUFVUIE1BTklGRVNULkpTT04gRU5EIC0tLS0tLS0tLS0tICovXG4gICAgfSxcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBtYW5pZmVzdElucHV0XG4iLCJpbXBvcnQgeyBPdXRwdXRBc3NldCwgT3V0cHV0Q2h1bmssIFBsdWdpbiB9IGZyb20gJ3JvbGx1cCdcblxuaW50ZXJmYWNlIE1hbmlmZXN0QXNzZXQgZXh0ZW5kcyBPdXRwdXRBc3NldCB7XG4gIHNvdXJjZTogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFZhbGlkYXRlTmFtZXNQbHVnaW4gPSBQaWNrPFxuICBSZXF1aXJlZDxQbHVnaW4+LFxuICAnbmFtZScgfCAnZ2VuZXJhdGVCdW5kbGUnXG4+XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZU5hbWVzID0gKCk6IFZhbGlkYXRlTmFtZXNQbHVnaW4gPT4gKHtcbiAgbmFtZTogJ3ZhbGlkYXRlLW5hbWVzJyxcblxuICBnZW5lcmF0ZUJ1bmRsZShvcHRpb25zLCBidW5kbGUpIHtcbiAgICBjb25zdCBjaHVua3MgPSBPYmplY3QudmFsdWVzKGJ1bmRsZSkuZmlsdGVyKFxuICAgICAgKHgpOiB4IGlzIE91dHB1dENodW5rID0+IHgudHlwZSA9PT0gJ2NodW5rJyxcbiAgICApXG5cbiAgICAvLyBGaWxlcyBjYW5ub3Qgc3RhcnQgd2l0aCBcIl9cIiBpbiBDaHJvbWUgRXh0ZW5zaW9uc1xuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIGZpbGUgYW5kIGNoZWNrIGZvciBcIl9cIiBpbiBmaWxlbmFtZVxuICAgIE9iamVjdC5rZXlzKGJ1bmRsZSlcbiAgICAgIC5maWx0ZXIoKGZpbGVOYW1lKSA9PiBmaWxlTmFtZS5zdGFydHNXaXRoKCdfJykpXG4gICAgICAuZm9yRWFjaCgoZmlsZU5hbWUpID0+IHtcbiAgICAgICAgLy8gT25seSByZXBsYWNlIGZpcnN0IGluc3RhbmNlXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChmaWxlTmFtZSlcbiAgICAgICAgY29uc3QgZml4ZWQgPSBmaWxlTmFtZS5zbGljZSgxKVxuXG4gICAgICAgIC8vIEZpeCBtYW5pZmVzdFxuICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGJ1bmRsZVsnbWFuaWZlc3QuanNvbiddIGFzIE1hbmlmZXN0QXNzZXRcbiAgICAgICAgbWFuaWZlc3Quc291cmNlID0gbWFuaWZlc3Quc291cmNlLnJlcGxhY2UocmVnZXgsIGZpeGVkKVxuXG4gICAgICAgIC8vIENoYW5nZSBidW5kbGUga2V5XG4gICAgICAgIGNvbnN0IGNodW5rID0gYnVuZGxlW2ZpbGVOYW1lXVxuICAgICAgICBkZWxldGUgYnVuZGxlW2ZpbGVOYW1lXVxuICAgICAgICBidW5kbGVbZml4ZWRdID0gY2h1bmtcblxuICAgICAgICAvLyBGaXggY2h1bmtcbiAgICAgICAgY2h1bmsuZmlsZU5hbWUgPSBmaXhlZFxuXG4gICAgICAgIC8vIEZpbmQgaW1wb3J0cyBhbmQgZml4XG4gICAgICAgIGNodW5rc1xuICAgICAgICAgIC5maWx0ZXIoKHsgaW1wb3J0cyB9KSA9PiBpbXBvcnRzLmluY2x1ZGVzKGZpbGVOYW1lKSlcbiAgICAgICAgICAuZm9yRWFjaCgoY2h1bmspID0+IHtcbiAgICAgICAgICAgIC8vIEZpeCBpbXBvcnRzIGxpc3RcbiAgICAgICAgICAgIGNodW5rLmltcG9ydHMgPSBjaHVuay5pbXBvcnRzLm1hcCgoaSkgPT5cbiAgICAgICAgICAgICAgaSA9PT0gZmlsZU5hbWUgPyBmaXhlZCA6IGksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAvLyBGaXggaW1wb3J0cyBpbiBjb2RlXG4gICAgICAgICAgICBjaHVuay5jb2RlID0gY2h1bmsuY29kZS5yZXBsYWNlKHJlZ2V4LCBmaXhlZClcbiAgICAgICAgICB9KVxuICAgICAgfSlcbiAgfSxcbn0pXG4iLCJleHBvcnQgY29uc3QgYmFja2dyb3VuZFBhZ2VSZWxvYWRlciA9ICdiYWNrZ3JvdW5kLXBhZ2UtcmVsb2FkZXIuanMnXG5leHBvcnQgY29uc3QgY29udGVudFNjcmlwdFJlbG9hZGVyID0gJ2NvbnRlbnQtc2NyaXB0LXJlbG9hZGVyLmpzJ1xuZXhwb3J0IGNvbnN0IHRpbWVzdGFtcEZpbGVuYW1lID0gJ3RpbWVzdGFtcC5qc29uJ1xuXG5leHBvcnQgY29uc3QgdGltZXN0YW1wUGF0aFBsYWNlaG9sZGVyID0gJyVUSU1FU1RBTVBfUEFUSCUnXG5leHBvcnQgY29uc3QgbG9hZE1lc3NhZ2VQbGFjZWhvbGRlciA9ICclTE9BRF9NRVNTQUdFJSdcbiIsImltcG9ydCB7IGNvZGUgYXMgYmdDbGllbnRDb2RlIH0gZnJvbSAnY29kZSAuL2NsaWVudC9iYWNrZ3JvdW5kLnRzJ1xuaW1wb3J0IHsgY29kZSBhcyBjdENsaWVudENvZGUgfSBmcm9tICdjb2RlIC4vY2xpZW50L2NvbnRlbnQudHMnXG5pbXBvcnQgeyBvdXRwdXRKc29uIH0gZnJvbSAnZnMtZXh0cmEnXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCdcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3JvbGx1cCdcbmltcG9ydCB7IHVwZGF0ZU1hbmlmZXN0IH0gZnJvbSAnLi4vaGVscGVycydcbmltcG9ydCB7XG4gIGJhY2tncm91bmRQYWdlUmVsb2FkZXIsXG4gIGNvbnRlbnRTY3JpcHRSZWxvYWRlcixcbiAgdGltZXN0YW1wUGF0aFBsYWNlaG9sZGVyLFxuICBsb2FkTWVzc2FnZVBsYWNlaG9sZGVyLFxuICB0aW1lc3RhbXBGaWxlbmFtZSxcbn0gZnJvbSAnLi9DT05TVEFOVFMnXG5cbmV4cG9ydCB0eXBlIFNpbXBsZVJlbG9hZGVyUGx1Z2luID0gUGljazxcbiAgUmVxdWlyZWQ8UGx1Z2luPixcbiAgJ25hbWUnIHwgJ2dlbmVyYXRlQnVuZGxlJyB8ICd3cml0ZUJ1bmRsZSdcbj5cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVSZWxvYWRlckNhY2hlIHtcbiAgYmdTY3JpcHRQYXRoPzogc3RyaW5nXG4gIGN0U2NyaXB0UGF0aD86IHN0cmluZ1xuICB0aW1lc3RhbXBQYXRoPzogc3RyaW5nXG4gIG91dHB1dERpcj86IHN0cmluZ1xuICBsb2FkTWVzc2FnZT86IHN0cmluZ1xufVxuXG4vLyBVc2VkIGZvciB0ZXN0aW5nXG5leHBvcnQgY29uc3QgX2ludGVybmFsQ2FjaGU6IFNpbXBsZVJlbG9hZGVyQ2FjaGUgPSB7fVxuXG5leHBvcnQgY29uc3Qgc2ltcGxlUmVsb2FkZXIgPSAoXG4gIGNhY2hlID0ge30gYXMgU2ltcGxlUmVsb2FkZXJDYWNoZSxcbik6IFNpbXBsZVJlbG9hZGVyUGx1Z2luIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKCFwcm9jZXNzLmVudi5ST0xMVVBfV0FUQ0gpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdjaHJvbWUtZXh0ZW5zaW9uLXNpbXBsZS1yZWxvYWRlcicsXG5cbiAgICBnZW5lcmF0ZUJ1bmRsZSh7IGRpciB9LCBidW5kbGUpIHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICBjb25zdCB0aW1lID0gYCR7ZGF0ZVxuICAgICAgICAuZ2V0RnVsbFllYXIoKVxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAucGFkU3RhcnQoMiwgJzAnKX0tJHsoZGF0ZS5nZXRNb250aCgpICsgMSlcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnBhZFN0YXJ0KDIsICcwJyl9LSR7ZGF0ZVxuICAgICAgICAuZ2V0RGF0ZSgpXG4gICAgICAgIC50b1N0cmluZygpXG4gICAgICAgIC5wYWRTdGFydCgyLCAnMCcpfSAke2RhdGVcbiAgICAgICAgLmdldEhvdXJzKClcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnBhZFN0YXJ0KDIsICcwJyl9OiR7ZGF0ZVxuICAgICAgICAuZ2V0TWludXRlcygpXG4gICAgICAgIC50b1N0cmluZygpXG4gICAgICAgIC5wYWRTdGFydCgyLCAnMCcpfToke2RhdGVcbiAgICAgICAgLmdldFNlY29uZHMoKVxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAucGFkU3RhcnQoMiwgJzAnKX1gXG5cbiAgICAgIGNhY2hlLm91dHB1dERpciA9IGRpclxuICAgICAgY2FjaGUubG9hZE1lc3NhZ2UgPSBbXG4gICAgICAgICdERVZFTE9QTUVOVCBidWlsZCB3aXRoIHNpbXBsZSBhdXRvLXJlbG9hZGVyJyxcbiAgICAgICAgYFske3RpbWV9XSB3YWl0aW5nIGZvciBjaGFuZ2VzLi4uYCxcbiAgICAgIF0uam9pbignXFxuJylcblxuICAgICAgLyogLS0tLS0tLS0tLS0tLS0tIEVNSVQgQ0xJRU5UIEZJTEVTIC0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICBjb25zdCBlbWl0ID0gKFxuICAgICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICAgIHNvdXJjZTogc3RyaW5nLFxuICAgICAgICBpc0ZpbGVOYW1lPzogYm9vbGVhbixcbiAgICAgICkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuZW1pdEZpbGUoe1xuICAgICAgICAgIHR5cGU6ICdhc3NldCcsXG4gICAgICAgICAgW2lzRmlsZU5hbWUgPyAnZmlsZU5hbWUnIDogJ25hbWUnXTogbmFtZSxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZU5hbWUoaWQpXG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnRpbWVzdGFtcFBhdGggPSBlbWl0KFxuICAgICAgICB0aW1lc3RhbXBGaWxlbmFtZSxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoRGF0ZS5ub3coKSksXG4gICAgICAgIHRydWUsXG4gICAgICApXG5cbiAgICAgIGNhY2hlLmJnU2NyaXB0UGF0aCA9IGVtaXQoXG4gICAgICAgIGJhY2tncm91bmRQYWdlUmVsb2FkZXIsXG4gICAgICAgIGJnQ2xpZW50Q29kZVxuICAgICAgICAgIC5yZXBsYWNlKHRpbWVzdGFtcFBhdGhQbGFjZWhvbGRlciwgY2FjaGUudGltZXN0YW1wUGF0aClcbiAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgIGxvYWRNZXNzYWdlUGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShjYWNoZS5sb2FkTWVzc2FnZSksXG4gICAgICAgICAgKSxcbiAgICAgIClcblxuICAgICAgY2FjaGUuY3RTY3JpcHRQYXRoID0gZW1pdChcbiAgICAgICAgY29udGVudFNjcmlwdFJlbG9hZGVyLFxuICAgICAgICBjdENsaWVudENvZGUucmVwbGFjZShcbiAgICAgICAgICBsb2FkTWVzc2FnZVBsYWNlaG9sZGVyLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGNhY2hlLmxvYWRNZXNzYWdlKSxcbiAgICAgICAgKSxcbiAgICAgIClcblxuICAgICAgLy8gVXBkYXRlIHRoZSBleHBvcnRlZCBjYWNoZVxuICAgICAgT2JqZWN0LmFzc2lnbihfaW50ZXJuYWxDYWNoZSwgY2FjaGUpXG5cbiAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0gVVBEQVRFIE1BTklGRVNUIC0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgdXBkYXRlTWFuaWZlc3QoXG4gICAgICAgIChtYW5pZmVzdCkgPT4ge1xuICAgICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLSBERVNDUklQVElPTiAtLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICAgIG1hbmlmZXN0LmRlc2NyaXB0aW9uID0gY2FjaGUubG9hZE1lc3NhZ2VcblxuICAgICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0gQkFDS0dST1VORCBQQUdFIC0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICAgIGlmICghbWFuaWZlc3QuYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgbWFuaWZlc3QuYmFja2dyb3VuZCA9IHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWFuaWZlc3QuYmFja2dyb3VuZC5wZXJzaXN0ZW50ID0gdHJ1ZVxuXG4gICAgICAgICAgY29uc3QgeyBzY3JpcHRzOiBiZ1NjcmlwdHMgPSBbXSB9ID0gbWFuaWZlc3QuYmFja2dyb3VuZFxuXG4gICAgICAgICAgaWYgKGNhY2hlLmJnU2NyaXB0UGF0aCkge1xuICAgICAgICAgICAgbWFuaWZlc3QuYmFja2dyb3VuZC5zY3JpcHRzID0gW1xuICAgICAgICAgICAgICBjYWNoZS5iZ1NjcmlwdFBhdGgsXG4gICAgICAgICAgICAgIC4uLmJnU2NyaXB0cyxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcbiAgICAgICAgICAgICAgYGNhY2hlLmJnU2NyaXB0UGF0aCBpcyAke3R5cGVvZiBjYWNoZS5iZ1NjcmlwdFBhdGh9YCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tIENPTlRFTlQgU0NSSVBUUyAtLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgICBjb25zdCB7IGNvbnRlbnRfc2NyaXB0czogY3RTY3JpcHRzID0gW10gfSA9IG1hbmlmZXN0XG5cbiAgICAgICAgICBpZiAoY2FjaGUuY3RTY3JpcHRQYXRoKSB7XG4gICAgICAgICAgICBtYW5pZmVzdC5jb250ZW50X3NjcmlwdHMgPSBjdFNjcmlwdHMubWFwKFxuICAgICAgICAgICAgICAoeyBqcyA9IFtdLCAuLi5yZXN0IH0pID0+ICh7XG4gICAgICAgICAgICAgICAganM6IFtjYWNoZS5jdFNjcmlwdFBhdGghLCAuLi5qc10sXG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXG4gICAgICAgICAgICAgIGBjYWNoZS5jdFNjcmlwdFBhdGggaXMgJHt0eXBlb2YgY2FjaGUuY3RTY3JpcHRQYXRofWAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1hbmlmZXN0XG4gICAgICAgIH0sXG4gICAgICAgIGJ1bmRsZSxcbiAgICAgICAgdGhpcy5lcnJvcixcbiAgICAgIClcblxuICAgICAgLy8gV2UnbGwgd3JpdGUgdGhpcyBmaWxlIG91cnNlbHZlcywgd2UganVzdCBuZWVkIGEgc2FmZSBwYXRoIHRvIHdyaXRlIHRoZSB0aW1lc3RhbXBcbiAgICAgIGRlbGV0ZSBidW5kbGVbY2FjaGUudGltZXN0YW1wUGF0aF1cbiAgICB9LFxuXG4gICAgLyogLS0tLS0tLS0tLS0tLS0gV1JJVEUgVElNRVNUQU1QIEZJTEUgLS0tLS0tLS0tLS0tLSAqL1xuICAgIGFzeW5jIHdyaXRlQnVuZGxlKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb3V0cHV0SnNvbihcbiAgICAgICAgICBqb2luKGNhY2hlLm91dHB1dERpciEsIGNhY2hlLnRpbWVzdGFtcFBhdGghKSxcbiAgICAgICAgICBEYXRlLm5vdygpLFxuICAgICAgICApXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKFxuICAgICAgICAgICAgYFVuYWJsZSB0byB1cGRhdGUgdGltZXN0YW1wIGZpbGU6XFxuXFx0JHtlcnIubWVzc2FnZX1gLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVycm9yKCdVbmFibGUgdG8gdXBkYXRlIHRpbWVzdGFtcCBmaWxlJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH1cbn1cbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3JvbGx1cCdcbmltcG9ydCBodG1sSW5wdXRzLCB7XG4gIEh0bWxJbnB1dHNQbHVnaW4sXG59IGZyb20gJy4vaHRtbC1pbnB1dHMvaW5kZXgnXG5pbXBvcnQgbWFuaWZlc3RJbnB1dCwge1xuICBNYW5pZmVzdElucHV0UGx1Z2luLFxufSBmcm9tICcuL21hbmlmZXN0LWlucHV0L2luZGV4J1xuaW1wb3J0IHtcbiAgdmFsaWRhdGVOYW1lcyBhcyB2LFxuICBWYWxpZGF0ZU5hbWVzUGx1Z2luLFxufSBmcm9tICcuL3ZhbGlkYXRlLW5hbWVzL2luZGV4J1xuaW1wb3J0IHsgcmVhZEpTT05TeW5jIH0gZnJvbSAnZnMtZXh0cmEnXG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCdcbmltcG9ydCB7IER5bmFtaWNJbXBvcnRXcmFwcGVyT3B0aW9ucyB9IGZyb20gJy4vbWFuaWZlc3QtaW5wdXQvZHluYW1pY0ltcG9ydFdyYXBwZXInXG5cbmV4cG9ydCB0eXBlIENocm9tZUV4dGVuc2lvblBsdWdpbiA9IFBpY2s8XG4gIFJlcXVpcmVkPFBsdWdpbj4sXG4gIHwgJ25hbWUnXG4gIHwgJ29wdGlvbnMnXG4gIHwgJ2J1aWxkU3RhcnQnXG4gIHwgJ3dhdGNoQ2hhbmdlJ1xuICB8ICdnZW5lcmF0ZUJ1bmRsZSdcbj4gJiB7XG4gIC8vIEZvciB0ZXN0aW5nXG4gIF9wbHVnaW5zOiB7XG4gICAgbWFuaWZlc3Q6IE1hbmlmZXN0SW5wdXRQbHVnaW5cbiAgICBodG1sOiBIdG1sSW5wdXRzUGx1Z2luXG4gICAgdmFsaWRhdGU6IFZhbGlkYXRlTmFtZXNQbHVnaW5cbiAgfVxufVxuXG5leHBvcnQgeyBzaW1wbGVSZWxvYWRlciB9IGZyb20gJy4vcGx1Z2luLXJlbG9hZGVyLXNpbXBsZS9pbmRleCdcblxuZXhwb3J0IGludGVyZmFjZSBDaHJvbWVFeHRlbnNpb25PcHRpb25zIHtcbiAgZHluYW1pY0ltcG9ydFdyYXBwZXI/OiBEeW5hbWljSW1wb3J0V3JhcHBlck9wdGlvbnNcbiAgdmVyYm9zZT86IGJvb2xlYW5cbiAgcGtnPzoge1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgICBuYW1lOiBzdHJpbmdcbiAgICB2ZXJzaW9uOiBzdHJpbmdcbiAgfVxuICBwdWJsaWNLZXk/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGNvbnN0IGNocm9tZUV4dGVuc2lvbiA9IChcbiAgb3B0aW9ucyA9IHt9IGFzIENocm9tZUV4dGVuc2lvbk9wdGlvbnMsXG4pOiBDaHJvbWVFeHRlbnNpb25QbHVnaW4gPT4ge1xuICAvKiAtLS0tLS0tLS0tLS0tLS0gTE9BRCBQQUNLQUdFLkpTT04gLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSBqb2luKHByb2Nlc3MuY3dkKCksICdwYWNrYWdlLmpzb24nKVxuICAgIG9wdGlvbnMucGtnID0gb3B0aW9ucy5wa2cgfHwgcmVhZEpTT05TeW5jKHBhY2thZ2VKc29uUGF0aClcbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0gU0VUVVAgUExVR0lOUyAtLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIGNvbnN0IG1hbmlmZXN0ID0gbWFuaWZlc3RJbnB1dChvcHRpb25zKVxuICBjb25zdCBodG1sID0gaHRtbElucHV0cyhtYW5pZmVzdClcbiAgY29uc3QgdmFsaWRhdGUgPSB2KClcblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLSBSRVRVUk4gUExVR0lOIC0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnY2hyb21lLWV4dGVuc2lvbicsXG5cbiAgICAvLyBGb3IgdGVzdGluZ1xuICAgIF9wbHVnaW5zOiB7IG1hbmlmZXN0LCBodG1sLCB2YWxpZGF0ZSB9LFxuXG4gICAgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gW21hbmlmZXN0LCBodG1sXS5yZWR1Y2UoKG9wdHMsIHBsdWdpbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBsdWdpbi5vcHRpb25zLmNhbGwodGhpcywgb3B0cylcblxuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgb3B0aW9uc1xuICAgICAgICB9LCBvcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbWFuaWZlc3RFcnJvciA9XG4gICAgICAgICAgJ1RoZSBtYW5pZmVzdCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHNjcmlwdCBvciBIVE1MIGZpbGUuJ1xuICAgICAgICBjb25zdCBodG1sRXJyb3IgPVxuICAgICAgICAgICdBdCBsZWFzdCBvbmUgSFRNTCBmaWxlIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc2NyaXB0LidcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgZXJyb3IubWVzc2FnZSA9PT0gbWFuaWZlc3RFcnJvciB8fFxuICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPT09IGh0bWxFcnJvclxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQSBDaHJvbWUgZXh0ZW5zaW9uIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc2NyaXB0IG9yIEhUTUwgZmlsZS4nLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGJ1aWxkU3RhcnQob3B0aW9ucykge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBtYW5pZmVzdC5idWlsZFN0YXJ0LmNhbGwodGhpcywgb3B0aW9ucyksXG4gICAgICAgIGh0bWwuYnVpbGRTdGFydC5jYWxsKHRoaXMsIG9wdGlvbnMpLFxuICAgICAgXSlcbiAgICB9LFxuXG4gICAgd2F0Y2hDaGFuZ2UoaWQpIHtcbiAgICAgIG1hbmlmZXN0LndhdGNoQ2hhbmdlLmNhbGwodGhpcywgaWQpXG4gICAgICBodG1sLndhdGNoQ2hhbmdlLmNhbGwodGhpcywgaWQpXG4gICAgfSxcblxuICAgIGFzeW5jIGdlbmVyYXRlQnVuZGxlKC4uLmFyZ3MpIHtcbiAgICAgIGF3YWl0IG1hbmlmZXN0LmdlbmVyYXRlQnVuZGxlLmNhbGwodGhpcywgLi4uYXJncylcbiAgICAgIGF3YWl0IHZhbGlkYXRlLmdlbmVyYXRlQnVuZGxlLmNhbGwodGhpcywgLi4uYXJncylcbiAgICB9LFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3NCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7In0=
